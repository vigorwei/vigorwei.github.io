[{"content":"Spring 的 Bean 默认都是单例的，某些情况下，单例是并发不安全的，以 Controller 举例，问题根源在于，我们可能会在 Controller 中定义成员变量，如此一来，多个请求来临，进入的都是同一个单例的 Controller 对象，并对此成员变量的值进行修改操作，因此会互相影响，无法达到并发安全（不同于线程隔离的概念，后面会解释到）的效果。\n1 2 3 4 5 6 7 8 9  @Controller public class Controller { private int i; @Bean @ResponseBody public int test() { return ++i; } }   多次访问此 url，可以看到每次的结果都是自增的，所以这样的代码显然是并发不安全的。\n1、单例变原型 对 web 项目，可以 Controller 类上加注解@Scope(\u0026quot;prototype\u0026quot;) 或 @Scope(\u0026quot;request\u0026quot;)，对非 web 项目，在 Component 类上添加注解 @Scope(\u0026quot;prototype\u0026quot;) 。\n这种方式实现起来非常简单，但增大了 Bean 创建实例化销毁的服务器资源开销。\n2、尽量避免使用成员变量 这尽量避免这么用单例 Bean 的成员变量，在业务允许的条件下，将成员变量替换为 RequestMapping 方法中的局部变量，多省事。这种方式自然是最恰当的，本人也是最推荐。代码修改如下\n1 2 3 4 5 6 7 8 9  @Controller public class ontroller { @GetMapping(\u0026#34;test\u0026#34;) @ResponseBody public int test() { int i = 0; return ++i; } }   3、使用并发安全的类 Java 作为功能性超强的编程语言，API 丰富，如果非要在单例 Bean 中使用成员变量，可以考虑使用并发安全的容器，如 ConcurrentHashMap、ConcurrentHashSet 等等，将我们的成员变量（一般可以是当前运行中的任务列表等这类变量）包装到这些并发安全的容器中进行管理即可。\n4、分布式或微服务的并发安全 如果还要进一步考虑到微服务或分布式服务的影响，方式 3 便不足以处理了，所以可以借助于可以共享某些信息的分布式缓存中间件如 Redis 等，这样即可保证同一种服务的不同服务实例都拥有同一份共享信息（如当前运行中的任务列表等这类变量）。\n","date":"2022-05-08T15:50:56+08:00","image":"https://vigorwei.github.io/p/spring%E5%8D%95%E4%BE%8Bbean%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/Snipaste_2022-05-08_16-04-01_hudd11e03f6f1025e3eb66a8caeb94c8f9_10539_120x120_fill_box_smart1_3.png","permalink":"https://vigorwei.github.io/p/spring%E5%8D%95%E4%BE%8Bbean%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/","title":"Spring单例Bean怎么保证并发安全"},{"content":"[TOC]\n一、SpringMVC简介 1、什么是MVC MVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分\nM：Model，模型层，指工程中的JavaBean，作用是处理数据\nJavaBean分为两类：\n 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。  V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据\nC：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器\nMVC的工作流程： 用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器\n2、什么是SpringMVC SpringMVC是Spring的一个后续产品，是Spring的一个子项目\nSpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。\n 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet\n 3、SpringMVC的特点  Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求  二、HelloWorld 1、开发环境 IDE：idea 2019.2\n构建工具：maven3.5.4\n服务器：tomcat7\nSpring版本：5.3.1\n2、创建maven工程 a\u0026gt;添加web模块 b\u0026gt;打包方式：war c\u0026gt;引入依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  \u0026lt;dependencies\u0026gt; \u0026lt;!-- SpringMVC --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 日志 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- ServletAPI --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- Spring5和Thymeleaf整合包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-spring5\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.12.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。\n3、配置web.xml 注册SpringMVC的前端控制器DispatcherServlet\na\u0026gt;默认配置方式 此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为\u0026lt;servlet-name\u0026gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;   b\u0026gt;扩展配置方式 可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  \u0026lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;springMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;!-- contextConfigLocation为固定值 --\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --\u0026gt; \u0026lt;param-value\u0026gt;classpath:springMVC.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;springMVC\u0026lt;/servlet-name\u0026gt; \u0026lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt;    注：\n\u0026lt;url-pattern\u0026gt;标签中使用/和/*的区别：\n/所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求\n因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面\n/*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法\n 4、创建请求控制器 由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器\n请求控制器中每一个处理请求的方法成为控制器方法\n因为SpringMVC的控制器由一个POJO（plain oder java object普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在\n1 2 3 4  @Controller public class HelloController { }   5、创建springMVC的配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  \u0026lt;!-- 自动扫描包 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu.mvc.controller\u0026#34;/\u0026gt; \u0026lt;!-- 配置Thymeleaf视图解析器 --\u0026gt; \u0026lt;bean id=\u0026#34;viewResolver\u0026#34; class=\u0026#34;org.thymeleaf.spring5.view.ThymeleafViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;order\u0026#34; value=\u0026#34;1\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;characterEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;templateEngine\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.thymeleaf.spring5.SpringTemplateEngine\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;templateResolver\u0026#34;\u0026gt; \u0026lt;bean class=\u0026#34;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver\u0026#34;\u0026gt; \u0026lt;!-- 视图前缀 --\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/templates/\u0026#34;/\u0026gt; \u0026lt;!-- 视图后缀 --\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.html\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;templateMode\u0026#34; value=\u0026#34;HTML5\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;characterEncoding\u0026#34; value=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置\u0026lt;mvc:annotation-driven/\u0026gt;解决问题 --\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!-- 开启mvc注解驱动 --\u0026gt; \u0026lt;mvc:annotation-driven\u0026gt; \u0026lt;mvc:message-converters\u0026gt; \u0026lt;!-- 处理响应中文内容乱码 --\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.http.converter.StringHttpMessageConverter\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;defaultCharset\u0026#34; value=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;supportedMediaTypes\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;text/html\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;application/json\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/mvc:message-converters\u0026gt; \u0026lt;/mvc:annotation-driven\u0026gt;   6、测试HelloWorld a\u0026gt;实现对首页的访问 在请求控制器中创建处理请求的方法\n1 2 3 4 5 6 7 8  // @RequestMapping注解：处理请求和控制器方法之间的映射关系 // @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径 // localhost:8080/springMVC/ @RequestMapping(\u0026#34;/\u0026#34;) public String index() { //设置视图名称  return \u0026#34;index\u0026#34;; }   b\u0026gt;通过超链接跳转到指定页面 在主页index.html中设置超链接\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;首页\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt; \u0026lt;a th:href=\u0026#34;@{/hello}\u0026#34;\u0026gt;HelloWorld\u0026lt;/a\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   在请求控制器中创建处理请求的方法\n1 2 3 4  @RequestMapping(\u0026#34;/hello\u0026#34;) public String HelloWorld() { return \u0026#34;target\u0026#34;; }   7、总结 浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面\n三、@RequestMapping注解 1、@RequestMapping注解的功能 从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。\nSpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。\n2、@RequestMapping注解的位置 @RequestMapping标识一个类：设置映射请求的请求路径的初始信息\n@RequestMapping标识一个方法：设置映射请求请求路径的具体信息\n1 2 3 4 5 6 7 8 9 10 11  @Controller @RequestMapping(\u0026#34;/test\u0026#34;) public class RequestMappingController { //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping  @RequestMapping(\u0026#34;/testRequestMapping\u0026#34;) public String testRequestMapping(){ return \u0026#34;success\u0026#34;; } }   3、@RequestMapping注解的value属性 @RequestMapping注解的value属性通过请求的请求地址匹配请求映射\n@RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求\n@RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射\n1 2  \u0026lt;a th:href=\u0026#34;@{/testRequestMapping}\u0026#34;\u0026gt;测试@RequestMapping的value属性--\u0026gt;/testRequestMapping\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;a th:href=\u0026#34;@{/test}\u0026#34;\u0026gt;测试@RequestMapping的value属性--\u0026gt;/test\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;   1 2 3 4 5 6  @RequestMapping( value = {\u0026#34;/testRequestMapping\u0026#34;, \u0026#34;/test\u0026#34;} ) public String testRequestMapping(){ return \u0026#34;success\u0026#34;; }   4、@RequestMapping注解的method属性 @RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射\n@RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求\n若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method \u0026lsquo;POST\u0026rsquo; not supported\n1 2 3 4  \u0026lt;a th:href=\u0026#34;@{/test}\u0026#34;\u0026gt;测试@RequestMapping的value属性--\u0026gt;/test\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;form th:action=\u0026#34;@{/test}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   1 2 3 4 5 6 7  @RequestMapping( value = {\u0026#34;/testRequestMapping\u0026#34;, \u0026#34;/test\u0026#34;}, method = {RequestMethod.GET, RequestMethod.POST} ) public String testRequestMapping(){ return \u0026#34;success\u0026#34;; }    注：\n1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解\n处理get请求的映射\u0026ndash;\u0026gt;@GetMapping\n处理post请求的映射\u0026ndash;\u0026gt;@PostMapping\n处理put请求的映射\u0026ndash;\u0026gt;@PutMapping\n处理delete请求的映射\u0026ndash;\u0026gt;@DeleteMapping\n2、常用的请求方式有get，post，put，delete\n但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理\n若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到\n 5、@RequestMapping注解的params属性（了解） @RequestMapping注解的params属性通过请求的请求参数匹配请求映射\n@RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系\n\u0026ldquo;param\u0026rdquo;：要求请求映射所匹配的请求必须携带param请求参数\n\u0026ldquo;!param\u0026rdquo;：要求请求映射所匹配的请求必须不能携带param请求参数\n\u0026ldquo;param=value\u0026rdquo;：要求请求映射所匹配的请求必须携带param请求参数且param=value\n\u0026ldquo;param!=value\u0026rdquo;：要求请求映射所匹配的请求必须携带param请求参数但是param!=value\n1  \u0026lt;a th:href=\u0026#34;@{/test(username=\u0026#39;admin\u0026#39;,password=123456)\u0026#34;\u0026gt;测试@RequestMapping的params属性--\u0026gt;/test\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;   1 2 3 4 5 6 7 8  @RequestMapping( value = {\u0026#34;/testRequestMapping\u0026#34;, \u0026#34;/test\u0026#34;} ,method = {RequestMethod.GET, RequestMethod.POST} ,params = {\u0026#34;username\u0026#34;,\u0026#34;password!=123456\u0026#34;} ) public String testRequestMapping(){ return \u0026#34;success\u0026#34;; }    注：\n若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions \u0026ldquo;username, password!=123456\u0026rdquo; not met for actual request parameters: username={admin}, password={123456}\n 6、@RequestMapping注解的headers属性（了解） @RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射\n@RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系\n\u0026ldquo;header\u0026rdquo;：要求请求映射所匹配的请求必须携带header请求头信息\n\u0026ldquo;!header\u0026rdquo;：要求请求映射所匹配的请求必须不能携带header请求头信息\n\u0026ldquo;header=value\u0026rdquo;：要求请求映射所匹配的请求必须携带header请求头信息且header=value\n\u0026ldquo;header!=value\u0026rdquo;：要求请求映射所匹配的请求必须携带header请求头信息且header!=value\n若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到\n7、SpringMVC支持ant风格的路径 ？：表示任意的单个字符\n*：表示任意的0个或多个字符\n**：表示任意的一层或多层目录\n注意：在使用**时，只能使用/**/xxx的方式\n8、SpringMVC支持路径中的占位符（重点） 原始方式：/deleteUser?id=1\nrest方式：/deleteUser/1\nSpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，在通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参\n1  \u0026lt;a th:href=\u0026#34;@{/testRest/1/admin}\u0026#34;\u0026gt;测试路径中的占位符--\u0026gt;/testRest\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;   1 2 3 4 5 6  @RequestMapping(\u0026#34;/testRest/{id}/{username}\u0026#34;) public String testRest(@PathVariable(\u0026#34;id\u0026#34;) String id, @PathVariable(\u0026#34;username\u0026#34;) String username){ System.out.println(\u0026#34;id:\u0026#34;+id+\u0026#34;,username:\u0026#34;+username); return \u0026#34;success\u0026#34;; } //最终输出的内容为--\u0026gt;id:1,username:admin   四、SpringMVC获取请求参数 1、通过ServletAPI获取 将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象\n1 2 3 4 5 6 7  @RequestMapping(\u0026#34;/testParam\u0026#34;) public String testParam(HttpServletRequest request){ String username = request.getParameter(\u0026#34;username\u0026#34;); String password = request.getParameter(\u0026#34;password\u0026#34;); System.out.println(\u0026#34;username:\u0026#34;+username+\u0026#34;,password:\u0026#34;+password); return \u0026#34;success\u0026#34;; }   2、通过控制器方法的形参获取请求参数 在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参\n1  \u0026lt;a th:href=\u0026#34;@{/testParam(username=\u0026#39;admin\u0026#39;,password=123456)}\u0026#34;\u0026gt;测试获取请求参数--\u0026gt;/testParam\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt;   1 2 3 4 5  @RequestMapping(\u0026#34;/testParam\u0026#34;) public String testParam(String username, String password){ System.out.println(\u0026#34;username:\u0026#34;+username+\u0026#34;,password:\u0026#34;+password); return \u0026#34;success\u0026#34;; }    注：\n若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数\n若使用字符串数组类型的形参，此参数的数组中包含了每一个数据\n若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果\n 3、@RequestParam @RequestParam是将请求参数和控制器方法的形参创建映射关系\n@RequestParam注解一共有三个属性：\nvalue：指定为形参赋值的请求参数的参数名\nrequired：设置是否必须传输此请求参数，默认值为true\n若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter \u0026lsquo;xxx\u0026rsquo; is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null\ndefaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为\u0026quot;\u0026ldquo;时，则使用默认值为形参赋值\n4、@RequestHeader @RequestHeader是将请求头信息和控制器方法的形参创建映射关系\n@RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n5、@CookieValue @CookieValue是将cookie数据和控制器方法的形参创建映射关系\n@CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam\n6、通过POJO获取请求参数 可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值\n1 2 3 4 5 6 7 8  \u0026lt;form th:action=\u0026#34;@{/testpojo}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 密码：\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 性别：\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;男\u0026#34;\u0026gt;男\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;sex\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;女\u0026lt;br\u0026gt; 年龄：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 邮箱：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   1 2 3 4 5 6  @RequestMapping(\u0026#34;/testpojo\u0026#34;) public String testPOJO(User user){ System.out.println(user); return \u0026#34;success\u0026#34;; } //最终结果--\u0026gt;User{id=null, username=\u0026#39;张三\u0026#39;, password=\u0026#39;123\u0026#39;, age=23, sex=\u0026#39;男\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;}   7、解决获取请求参数的乱码问题 解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;!--配置springMVC的编码过滤器--\u0026gt; \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.CharacterEncodingFilter\u0026lt;/filter-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;encoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;UTF-8\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;forceResponseEncoding\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;true\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;CharacterEncodingFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;    注：\nSpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效\n 五、域对象共享数据 1、使用ServletAPI向request域对象共享数据 1 2 3 4 5  @RequestMapping(\u0026#34;/testServletAPI\u0026#34;) public String testServletAPI(HttpServletRequest request){ request.setAttribute(\u0026#34;testScope\u0026#34;, \u0026#34;hello,servletAPI\u0026#34;); return \u0026#34;success\u0026#34;; }   2、使用ModelAndView向request域对象共享数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14  @RequestMapping(\u0026#34;/testModelAndView\u0026#34;) public ModelAndView testModelAndView(){ /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据  mav.addObject(\u0026#34;testScope\u0026#34;, \u0026#34;hello,ModelAndView\u0026#34;); //设置视图，实现页面跳转  mav.setViewName(\u0026#34;success\u0026#34;); return mav; }   3、使用Model向request域对象共享数据 1 2 3 4 5  @RequestMapping(\u0026#34;/testModel\u0026#34;) public String testModel(Model model){ model.addAttribute(\u0026#34;testScope\u0026#34;, \u0026#34;hello,Model\u0026#34;); return \u0026#34;success\u0026#34;; }   4、使用map向request域对象共享数据 1 2 3 4 5  @RequestMapping(\u0026#34;/testMap\u0026#34;) public String testMap(Map\u0026lt;String, Object\u0026gt; map){ map.put(\u0026#34;testScope\u0026#34;, \u0026#34;hello,Map\u0026#34;); return \u0026#34;success\u0026#34;; }   5、使用ModelMap向request域对象共享数据 1 2 3 4 5  @RequestMapping(\u0026#34;/testModelMap\u0026#34;) public String testModelMap(ModelMap modelMap){ modelMap.addAttribute(\u0026#34;testScope\u0026#34;, \u0026#34;hello,ModelMap\u0026#34;); return \u0026#34;success\u0026#34;; }   6、Model、ModelMap、Map的关系 Model、ModelMap、Map类型的参数其实本质上都是 BindingAwareModelMap 类型的\n1 2 3 4  public interface Model{} public class ModelMap extends LinkedHashMap\u0026lt;String, Object\u0026gt; {} public class ExtendedModelMap extends ModelMap implements Model {} public class BindingAwareModelMap extends ExtendedModelMap {}   7、向session域共享数据 1 2 3 4 5  @RequestMapping(\u0026#34;/testSession\u0026#34;) public String testSession(HttpSession session){ session.setAttribute(\u0026#34;testSessionScope\u0026#34;, \u0026#34;hello,session\u0026#34;); return \u0026#34;success\u0026#34;; }   8、向application域共享数据 1 2 3 4 5 6  @RequestMapping(\u0026#34;/testApplication\u0026#34;) public String testApplication(HttpSession session){ ServletContext application = session.getServletContext(); application.setAttribute(\u0026#34;testApplicationScope\u0026#34;, \u0026#34;hello,application\u0026#34;); return \u0026#34;success\u0026#34;; }   六、SpringMVC的视图 SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户\nSpringMVC视图的种类很多，默认有转发视图和重定向视图\n当工程引入jstl的依赖，转发视图会自动转换为JstlView\n若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView\n1、ThymeleafView 当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转\n1 2 3 4  @RequestMapping(\u0026#34;/testHello\u0026#34;) public String testHello(){ return \u0026#34;hello\u0026#34;; }   2、转发视图 SpringMVC中默认的转发视图是InternalResourceView\nSpringMVC中创建转发视图的情况：\n当控制器方法中所设置的视图名称以\u0026quot;forward:\u0026ldquo;为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀\u0026quot;forward:\u0026ldquo;去掉，剩余部分作为最终路径通过转发的方式实现跳转\n例如\u0026quot;forward:/\u0026quot;，\u0026ldquo;forward:/employee\u0026rdquo;\n1 2 3 4  @RequestMapping(\u0026#34;/testForward\u0026#34;) public String testForward(){ return \u0026#34;forward:/testHello\u0026#34;; }   3、重定向视图 SpringMVC中默认的重定向视图是RedirectView\n当控制器方法中所设置的视图名称以\u0026quot;redirect:\u0026ldquo;为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀\u0026quot;redirect:\u0026ldquo;去掉，剩余部分作为最终路径通过重定向的方式实现跳转\n例如\u0026quot;redirect:/\u0026quot;，\u0026ldquo;redirect:/employee\u0026rdquo;\n1 2 3 4  @RequestMapping(\u0026#34;/testRedirect\u0026#34;) public String testRedirect(){ return \u0026#34;redirect:/testHello\u0026#34;; }    注：\n重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径\n 4、视图控制器view-controller 当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示\n1 2 3 4 5  \u0026lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称 --\u0026gt; \u0026lt;mvc:view-controller path=\u0026#34;/testView\u0026#34; view-name=\u0026#34;success\u0026#34;\u0026gt;\u0026lt;/mvc:view-controller\u0026gt;    注：\n当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：\n\u0026lt;mvc:annotation-driven /\u0026gt;\n 七、RESTful 1、RESTful简介 REST：Representational State Transfer，表现层资源状态转移。\na\u0026gt;资源 资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。\nb\u0026gt;资源的表述 资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。\nc\u0026gt;状态转移 状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。\n2、RESTful的实现 具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。\n它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。\nREST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。\n   操作 传统方式 REST风格     查询操作 getUserById?id=1 user/1\u0026ndash;\u0026gt;get请求方式   保存操作 saveUser user\u0026ndash;\u0026gt;post请求方式   删除操作 deleteUser?id=1 user/1\u0026ndash;\u0026gt;delete请求方式   更新操作 updateUser user\u0026ndash;\u0026gt;put请求方式    3、HiddenHttpMethodFilter 由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？\nSpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求\nHiddenHttpMethodFilter 处理put和delete请求的条件：\na\u0026gt;当前请求的请求方式必须为post\nb\u0026gt;当前请求必须传输请求参数_method\n满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式\n在web.xml中注册HiddenHttpMethodFilter\n1 2 3 4 5 6 7 8  \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;org.springframework.web.filter.HiddenHttpMethodFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;HiddenHttpMethodFilter\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt;    注：\n目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter\n在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter\n原因：\n  在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的\n  request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作\n  而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作：\n  1  String paramValue = request.getParameter(this.methodParam);      八、RESTful案例 1、准备工作 和传统 CRUD 一样，实现对员工信息的增删改查。\n  搭建环境\n  准备实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  package com.atguigu.mvc.bean; public class Employee { private Integer id; private String lastName; private String email; //1 male, 0 female  private Integer gender; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } public Integer getGender() { return gender; } public void setGender(Integer gender) { this.gender = gender; } public Employee(Integer id, String lastName, String email, Integer gender) { super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; } public Employee() { } }     准备dao模拟数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  package com.atguigu.mvc.dao; import java.util.Collection; import java.util.HashMap; import java.util.Map; import com.atguigu.mvc.bean.Employee; import org.springframework.stereotype.Repository; @Repository public class EmployeeDao { private static Map\u0026lt;Integer, Employee\u0026gt; employees = null; static{ employees = new HashMap\u0026lt;Integer, Employee\u0026gt;(); employees.put(1001, new Employee(1001, \u0026#34;E-AA\u0026#34;, \u0026#34;aa@163.com\u0026#34;, 1)); employees.put(1002, new Employee(1002, \u0026#34;E-BB\u0026#34;, \u0026#34;bb@163.com\u0026#34;, 1)); employees.put(1003, new Employee(1003, \u0026#34;E-CC\u0026#34;, \u0026#34;cc@163.com\u0026#34;, 0)); employees.put(1004, new Employee(1004, \u0026#34;E-DD\u0026#34;, \u0026#34;dd@163.com\u0026#34;, 0)); employees.put(1005, new Employee(1005, \u0026#34;E-EE\u0026#34;, \u0026#34;ee@163.com\u0026#34;, 1)); } private static Integer initId = 1006; public void save(Employee employee){ if(employee.getId() == null){ employee.setId(initId++); } employees.put(employee.getId(), employee); } public Collection\u0026lt;Employee\u0026gt; getAll(){ return employees.values(); } public Employee get(Integer id){ return employees.get(id); } public void delete(Integer id){ employees.remove(id); } }     2、功能清单    功能 URL 地址 请求方式     访问首页√ / GET   查询全部数据√ /employee GET   删除√ /employee/2 DELETE   跳转到添加数据页面√ /toAdd GET   执行保存√ /employee POST   跳转到更新数据页面√ /employee/2 GET   执行更新√ /employee PUT    3、具体功能：访问首页 a\u0026gt;配置view-controller 1  \u0026lt;mvc:view-controller path=\u0026#34;/\u0026#34; view-name=\u0026#34;index\u0026#34;/\u0026gt;   b\u0026gt;创建页面 1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; \u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;首页\u0026lt;/h1\u0026gt; \u0026lt;a th:href=\u0026#34;@{/employee}\u0026#34;\u0026gt;访问员工信息\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   4、具体功能：查询所有员工数据 a\u0026gt;控制器方法 1 2 3 4 5 6  @RequestMapping(value = \u0026#34;/employee\u0026#34;, method = RequestMethod.GET) public String getEmployeeList(Model model){ Collection\u0026lt;Employee\u0026gt; employeeList = employeeDao.getAll(); model.addAttribute(\u0026#34;employeeList\u0026#34;, employeeList); return \u0026#34;employee_list\u0026#34;; }   b\u0026gt;创建employee_list.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Employee Info\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/static/js/vue.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table border=\u0026#34;1\u0026#34; cellpadding=\u0026#34;0\u0026#34; cellspacing=\u0026#34;0\u0026#34; style=\u0026#34;text-align: center;\u0026#34; id=\u0026#34;dataTable\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th colspan=\u0026#34;5\u0026#34;\u0026gt;Employee Info\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;id\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;lastName\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;email\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;gender\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;options(\u0026lt;a th:href=\u0026#34;@{/toAdd}\u0026#34;\u0026gt;add\u0026lt;/a\u0026gt;)\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr th:each=\u0026#34;employee : ${employeeList}\u0026#34;\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.id}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.lastName}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.email}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${employee.gender}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt; \u0026lt;a class=\u0026#34;deleteA\u0026#34; @click=\u0026#34;deleteEmployee\u0026#34; th:href=\u0026#34;@{\u0026#39;/employee/\u0026#39;+${employee.id}}\u0026#34;\u0026gt;delete\u0026lt;/a\u0026gt; \u0026lt;a th:href=\u0026#34;@{\u0026#39;/employee/\u0026#39;+${employee.id}}\u0026#34;\u0026gt;update\u0026lt;/a\u0026gt; \u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   5、具体功能：删除 a\u0026gt;创建处理delete请求方式的表单 1 2 3 4 5  \u0026lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --\u0026gt; \u0026lt;form id=\u0026#34;delete_form\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;_method\u0026#34; value=\u0026#34;delete\u0026#34;/\u0026gt; \u0026lt;/form\u0026gt;   b\u0026gt;删除超链接绑定点击事件 引入vue.js\n1  \u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/static/js/vue.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   删除超链接\n1  \u0026lt;a class=\u0026#34;deleteA\u0026#34; @click=\u0026#34;deleteEmployee\u0026#34; th:href=\u0026#34;@{\u0026#39;/employee/\u0026#39;+${employee.id}}\u0026#34;\u0026gt;delete\u0026lt;/a\u0026gt;   通过vue处理点击事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vue = new Vue({ el:\u0026#34;#dataTable\u0026#34;, methods:{ //event表示当前事件  deleteEmployee:function (event) { //通过id获取表单标签  var delete_form = document.getElementById(\u0026#34;delete_form\u0026#34;); //将触发事件的超链接的href属性为表单的action属性赋值  delete_form.action = event.target.href; //提交表单  delete_form.submit(); //阻止超链接的默认跳转行为  event.preventDefault(); } } }); \u0026lt;/script\u0026gt;   c\u0026gt;控制器方法 1 2 3 4 5  @RequestMapping(value = \u0026#34;/employee/{id}\u0026#34;, method = RequestMethod.DELETE) public String deleteEmployee(@PathVariable(\u0026#34;id\u0026#34;) Integer id){ employeeDao.delete(id); return \u0026#34;redirect:/employee\u0026#34;; }   6、具体功能：跳转到添加数据页面 a\u0026gt;配置view-controller 1  \u0026lt;mvc:view-controller path=\u0026#34;/toAdd\u0026#34; view-name=\u0026#34;employee_add\u0026#34;\u0026gt;\u0026lt;/mvc:view-controller\u0026gt;   b\u0026gt;创建employee_add.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Add Employee\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form th:action=\u0026#34;@{/employee}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; lastName:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;lastName\u0026#34;\u0026gt;\u0026lt;br\u0026gt; email:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;br\u0026gt; gender:\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34;\u0026gt;male \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;0\u0026#34;\u0026gt;female\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;add\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   7、具体功能：执行保存 a\u0026gt;控制器方法 1 2 3 4 5  @RequestMapping(value = \u0026#34;/employee\u0026#34;, method = RequestMethod.POST) public String addEmployee(Employee employee){ employeeDao.save(employee); return \u0026#34;redirect:/employee\u0026#34;; }   8、具体功能：跳转到更新数据页面 a\u0026gt;修改超链接 1  \u0026lt;a th:href=\u0026#34;@{\u0026#39;/employee/\u0026#39;+${employee.id}}\u0026#34;\u0026gt;update\u0026lt;/a\u0026gt;   b\u0026gt;控制器方法 1 2 3 4 5 6  @RequestMapping(value = \u0026#34;/employee/{id}\u0026#34;, method = RequestMethod.GET) public String getEmployeeById(@PathVariable(\u0026#34;id\u0026#34;) Integer id, Model model){ Employee employee = employeeDao.get(id); model.addAttribute(\u0026#34;employee\u0026#34;, employee); return \u0026#34;employee_update\u0026#34;; }   c\u0026gt;创建employee_update.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;http://www.thymeleaf.org\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Update Employee\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form th:action=\u0026#34;@{/employee}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;_method\u0026#34; value=\u0026#34;put\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;id\u0026#34; th:value=\u0026#34;${employee.id}\u0026#34;\u0026gt; lastName:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;lastName\u0026#34; th:value=\u0026#34;${employee.lastName}\u0026#34;\u0026gt;\u0026lt;br\u0026gt; email:\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;email\u0026#34; th:value=\u0026#34;${employee.email}\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;!-- th:field=\u0026#34;${employee.gender}\u0026#34;可用于单选框或复选框的回显 若单选框的value和employee.gender的值一致，则添加checked=\u0026#34;checked\u0026#34;属性 --\u0026gt; gender:\u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;1\u0026#34; th:field=\u0026#34;${employee.gender}\u0026#34;\u0026gt;male \u0026lt;input type=\u0026#34;radio\u0026#34; name=\u0026#34;gender\u0026#34; value=\u0026#34;0\u0026#34; th:field=\u0026#34;${employee.gender}\u0026#34;\u0026gt;female\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;update\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   9、具体功能：执行更新 a\u0026gt;控制器方法 1 2 3 4 5  @RequestMapping(value = \u0026#34;/employee\u0026#34;, method = RequestMethod.PUT) public String updateEmployee(Employee employee){ employeeDao.save(employee); return \u0026#34;redirect:/employee\u0026#34;; }   八、HttpMessageConverter HttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文\nHttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity，\nResponseEntity\n1、@RequestBody @RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值\n1 2 3 4 5  \u0026lt;form th:action=\u0026#34;@{/testRequestBody}\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; 用户名：\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 密码：\u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34;\u0026gt;\u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt;   1 2 3 4 5  @RequestMapping(\u0026#34;/testRequestBody\u0026#34;) public String testRequestBody(@RequestBody String requestBody){ System.out.println(\u0026#34;requestBody:\u0026#34;+requestBody); return \u0026#34;success\u0026#34;; }   输出结果：\nrequestBody:username=admin\u0026amp;password=123456\n2、RequestEntity RequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息\n1 2 3 4 5 6  @RequestMapping(\u0026#34;/testRequestEntity\u0026#34;) public String testRequestEntity(RequestEntity\u0026lt;String\u0026gt; requestEntity){ System.out.println(\u0026#34;requestHeader:\u0026#34;+requestEntity.getHeaders()); System.out.println(\u0026#34;requestBody:\u0026#34;+requestEntity.getBody()); return \u0026#34;success\u0026#34;; }   输出结果： requestHeader:[host:\u0026ldquo;localhost:8080\u0026rdquo;, connection:\u0026ldquo;keep-alive\u0026rdquo;, content-length:\u0026ldquo;27\u0026rdquo;, cache-control:\u0026ldquo;max-age=0\u0026rdquo;, sec-ch-ua:\u0026rdquo;\u0026rdquo; Not A;Brand\u0026rdquo;;v=\u0026ldquo;99\u0026rdquo;, \u0026ldquo;Chromium\u0026rdquo;;v=\u0026ldquo;90\u0026rdquo;, \u0026ldquo;Google Chrome\u0026rdquo;;v=\u0026ldquo;90\u0026quot;\u0026rdquo;, sec-ch-ua-mobile:\u0026quot;?0\u0026rdquo;, upgrade-insecure-requests:\u0026ldquo;1\u0026rdquo;, origin:\u0026ldquo;http://localhost:8080\u0026rdquo;, user-agent:\u0026ldquo;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36\u0026rdquo;] requestBody:username=admin\u0026amp;password=123\n3、@ResponseBody @ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器\n1 2 3 4 5  @RequestMapping(\u0026#34;/testResponseBody\u0026#34;) @ResponseBody public String testResponseBody(){ return \u0026#34;success\u0026#34;; }   结果：浏览器页面显示success\n4、SpringMVC处理json @ResponseBody处理json的步骤：\na\u0026gt;导入jackson的依赖\n1 2 3 4 5  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.12.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   b\u0026gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串\n1  \u0026lt;mvc:annotation-driven /\u0026gt;   c\u0026gt;在处理器方法上使用@ResponseBody注解进行标识\nd\u0026gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串\n1 2 3 4 5  @RequestMapping(\u0026#34;/testResponseUser\u0026#34;) @ResponseBody public User testResponseUser(){ return new User(1001,\u0026#34;admin\u0026#34;,\u0026#34;123456\u0026#34;,23,\u0026#34;男\u0026#34;); }   浏览器的页面中展示的结果：\n{\u0026ldquo;id\u0026rdquo;:1001,\u0026ldquo;username\u0026rdquo;:\u0026ldquo;admin\u0026rdquo;,\u0026ldquo;password\u0026rdquo;:\u0026ldquo;123456\u0026rdquo;,\u0026ldquo;age\u0026rdquo;:23,\u0026ldquo;sex\u0026rdquo;:\u0026ldquo;男\u0026rdquo;}\n5、SpringMVC处理ajax a\u0026gt;请求超链接：\n1 2 3  \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;a th:href=\u0026#34;@{/testAjax}\u0026#34; @click=\u0026#34;testAjax\u0026#34;\u0026gt;testAjax\u0026lt;/a\u0026gt;\u0026lt;br\u0026gt; \u0026lt;/div\u0026gt;   b\u0026gt;通过vue和axios处理点击事件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/static/js/vue.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; th:src=\u0026#34;@{/static/js/axios.min.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var vue = new Vue({ el:\u0026#34;#app\u0026#34;, methods:{ testAjax:function (event) { axios({ method:\u0026#34;post\u0026#34;, url:event.target.href, params:{ username:\u0026#34;admin\u0026#34;, password:\u0026#34;123456\u0026#34; } }).then(function (response) { alert(response.data); }); event.preventDefault(); } } }); \u0026lt;/script\u0026gt;   c\u0026gt;控制器方法：\n1 2 3 4 5 6  @RequestMapping(\u0026#34;/testAjax\u0026#34;) @ResponseBody public String testAjax(String username, String password){ System.out.println(\u0026#34;username:\u0026#34;+username+\u0026#34;,password:\u0026#34;+password); return \u0026#34;hello,ajax\u0026#34;; }   6、@RestController注解 @RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解\n7、ResponseEntity ResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文\n九、文件上传和下载 1、文件下载 使用ResponseEntity实现下载文件的功能\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  @RequestMapping(\u0026#34;/testDown\u0026#34;) public ResponseEntity\u0026lt;byte[]\u0026gt; testResponseEntity(HttpSession session) throws IOException { //获取ServletContext对象  ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径  String realPath = servletContext.getRealPath(\u0026#34;/static/img/1.jpg\u0026#34;); //创建输入流  InputStream is = new FileInputStream(realPath); //创建字节数组  byte[] bytes = new byte[is.available()]; //将流读到字节数组中  is.read(bytes); //创建HttpHeaders对象设置响应头信息  MultiValueMap\u0026lt;String, String\u0026gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字  headers.add(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment;filename=1.jpg\u0026#34;); //设置响应状态码  HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象  ResponseEntity\u0026lt;byte[]\u0026gt; responseEntity = new ResponseEntity\u0026lt;\u0026gt;(bytes, headers, statusCode); //关闭输入流  is.close(); return responseEntity; }   2、文件上传 文件上传要求form表单的请求方式必须为post，并且添加属性enctype=\u0026ldquo;multipart/form-data\u0026rdquo;\nSpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息\n上传步骤：\na\u0026gt;添加依赖：\n1 2 3 4 5 6  \u0026lt;!-- https://mvnrepository.com/artifact/commons-fileupload/commons-fileupload --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-fileupload\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-fileupload\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   b\u0026gt;在SpringMVC的配置文件中添加配置：\n1 2  \u0026lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象--\u0026gt; \u0026lt;bean id=\u0026#34;multipartResolver\u0026#34; class=\u0026#34;org.springframework.web.multipart.commons.CommonsMultipartResolver\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;   c\u0026gt;控制器方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  @RequestMapping(\u0026#34;/testUp\u0026#34;) public String testUp(MultipartFile photo, HttpSession session) throws IOException { //获取上传的文件的文件名  String fileName = photo.getOriginalFilename(); //处理文件重名问题  String hzName = fileName.substring(fileName.lastIndexOf(\u0026#34;.\u0026#34;)); fileName = UUID.randomUUID().toString() + hzName; //获取服务器中photo目录的路径  ServletContext servletContext = session.getServletContext(); String photoPath = servletContext.getRealPath(\u0026#34;photo\u0026#34;); File file = new File(photoPath); if(!file.exists()){ file.mkdir(); } String finalPath = photoPath + File.separator + fileName; //实现上传功能  photo.transferTo(new File(finalPath)); return \u0026#34;success\u0026#34;; }   十、拦截器 1、拦截器的配置 SpringMVC中的拦截器用于拦截控制器方法的执行\nSpringMVC中的拦截器需要实现HandlerInterceptor\nSpringMVC的拦截器必须在SpringMVC的配置文件中进行配置：\nfalse拦截，true放行\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;bean class=\u0026#34;com.atguigu.interceptor.FirstInterceptor\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;ref bean=\u0026#34;firstInterceptor\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --\u0026gt; \u0026lt;mvc:interceptor\u0026gt; \u0026lt;mvc:mapping path=\u0026#34;/**\u0026#34;/\u0026gt; \u0026lt;mvc:exclude-mapping path=\u0026#34;/testRequestEntity\u0026#34;/\u0026gt; \u0026lt;ref bean=\u0026#34;firstInterceptor\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/mvc:interceptor\u0026gt; \u0026lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求 --\u0026gt;   2、拦截器的三个抽象方法 SpringMVC中的拦截器有三个抽象方法：\npreHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法\npostHandle：控制器方法执行之后执行postHandle()\nafterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation()\n3、多个拦截器的执行顺序 a\u0026gt;若每个拦截器的preHandle()都返回true\n此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关：\npreHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行\nb\u0026gt;若某个拦截器的preHandle()返回了false\npreHandle()返回false和它之前的拦截器的preHandle()都会执行，postHandle()都不执行，返回false的拦截器之前的拦截器的afterComplation()会执行\n十一、异常处理器 1、基于配置的异常处理 SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver\nHandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver\nSpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;exceptionMappings\u0026#34;\u0026gt; \u0026lt;props\u0026gt; \u0026lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --\u0026gt; \u0026lt;prop key=\u0026#34;java.lang.ArithmeticException\u0026#34;\u0026gt;error\u0026lt;/prop\u0026gt; \u0026lt;/props\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 --\u0026gt; \u0026lt;property name=\u0026#34;exceptionAttribute\u0026#34; value=\u0026#34;ex\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   2、基于注解的异常处理 1 2 3 4 5 6 7 8 9 10 11 12 13  //@ControllerAdvice将当前类标识为异常处理的组件 @ControllerAdvice public class ExceptionController { //@ExceptionHandler用于设置所标识方法处理的异常  @ExceptionHandler(ArithmeticException.class) //ex表示当前请求处理中出现的异常对象  public String handleArithmeticException(Exception ex, Model model){ model.addAttribute(\u0026#34;ex\u0026#34;, ex); return \u0026#34;error\u0026#34;; } }   十二、注解配置SpringMVC 使用配置类和注解代替web.xml和SpringMVC配置文件的功能\n1、创建初始化类，代替web.xml 在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。 Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer { /** * 指定spring的配置类 * @return */ @Override protected Class\u0026lt;?\u0026gt;[] getRootConfigClasses() { return new Class[]{SpringConfig.class}; } /** * 指定SpringMVC的配置类 * @return */ @Override protected Class\u0026lt;?\u0026gt;[] getServletConfigClasses() { return new Class[]{WebConfig.class}; } /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() { return new String[]{\u0026#34;/\u0026#34;}; } /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() { CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(\u0026#34;UTF-8\u0026#34;); encodingFilter.setForceRequestEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]{encodingFilter, hiddenHttpMethodFilter}; } }   2、创建SpringConfig配置类，代替spring的配置文件 1 2 3 4  @Configuration public class SpringConfig { //ssm整合之后，spring的配置信息写在此类中 }   3、创建WebConfig配置类，代替SpringMVC的配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79  @Configuration //扫描组件 @ComponentScan(\u0026#34;com.atguigu.mvc.controller\u0026#34;) //开启MVC注解驱动 @EnableWebMvc public class WebConfig implements WebMvcConfigurer { //使用默认的servlet处理静态资源  @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } //配置文件上传解析器  @Bean public CommonsMultipartResolver multipartResolver(){ return new CommonsMultipartResolver(); } //配置拦截器  @Override public void addInterceptors(InterceptorRegistry registry) { FirstInterceptor firstInterceptor = new FirstInterceptor(); registry.addInterceptor(firstInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;); } //配置视图控制  /*@Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/\u0026#34;).setViewName(\u0026#34;index\u0026#34;); }*/ //配置异常映射  /*@Override public void configureHandlerExceptionResolvers(List\u0026lt;HandlerExceptionResolver\u0026gt; resolvers) { SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(\u0026#34;java.lang.ArithmeticException\u0026#34;, \u0026#34;error\u0026#34;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(\u0026#34;ex\u0026#34;); resolvers.add(exceptionResolver); }*/ //配置生成模板解析器  @Bean public ITemplateResolver templateResolver() { WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得  ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver( webApplicationContext.getServletContext()); templateResolver.setPrefix(\u0026#34;/WEB-INF/templates/\u0026#34;); templateResolver.setSuffix(\u0026#34;.html\u0026#34;); templateResolver.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; } //生成模板引擎并为模板引擎注入模板解析器  @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) { SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; } //生成视图解析器并未解析器注入模板引擎  @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) { ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(\u0026#34;UTF-8\u0026#34;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; } }   4、测试功能 1 2 3 4  @RequestMapping(\u0026#34;/\u0026#34;) public String index(){ return \u0026#34;index\u0026#34;; }   十三、SpringMVC执行流程 1、SpringMVC常用组件  DispatcherServlet：前端控制器，不需要工程师开发，由框架提供  作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求\n HandlerMapping：处理器映射器，不需要工程师开发，由框架提供  作用：根据请求的url、method等信息查找Handler，即控制器方法\n Handler：处理器，需要工程师开发  作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理\n HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供  作用：通过HandlerAdapter对处理器（控制器方法）进行执行\n ViewResolver：视图解析器，不需要工程师开发，由框架提供  作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView\n View：视图  作用：将模型数据通过页面展示给用户\n2、DispatcherServlet初始化过程 DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。\na\u0026gt;初始化WebApplicationContext 所在类：org.springframework.web.servlet.FrameworkServlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  protected WebApplicationContext initWebApplicationContext() { WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) { // A context instance was injected at construction time -\u0026gt; use it  wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) { ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) { // The context has not yet been refreshed -\u0026gt; provide services such as  // setting the parent context, setting the application context id, etc  if (cwac.getParent() == null) { // The context instance was injected without an explicit parent -\u0026gt; set  // the root application context (if any; may be null) as the parent  cwac.setParent(rootContext); } configureAndRefreshWebApplicationContext(cwac); } } } if (wac == null) { // No context instance was injected at construction time -\u0026gt; see if one  // has been registered in the servlet context. If one exists, it is assumed  // that the parent context (if any) has already been set and that the  // user has performed any initialization such as setting the context id  wac = findWebApplicationContext(); } if (wac == null) { // No context instance is defined for this servlet -\u0026gt; create a local one  // 创建WebApplicationContext  wac = createWebApplicationContext(rootContext); } if (!this.refreshEventReceived) { // Either the context is not a ConfigurableApplicationContext with refresh  // support or the context injected at construction time had already been  // refreshed -\u0026gt; trigger initial onRefresh manually here.  synchronized (this.onRefreshMonitor) { // 刷新WebApplicationContext  onRefresh(wac); } } if (this.publishContext) { // Publish the context as a servlet context attribute.  // 将IOC容器在应用域共享  String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); } return wac; }   b\u0026gt;创建WebApplicationContext 所在类：org.springframework.web.servlet.FrameworkServlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  protected WebApplicationContext createWebApplicationContext(@Nullable ApplicationContext parent) { Class\u0026lt;?\u0026gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) { throw new ApplicationContextException( \u0026#34;Fatal initialization error in servlet with name \u0026#39;\u0026#34; + getServletName() + \u0026#34;\u0026#39;: custom WebApplicationContext class [\u0026#34; + contextClass.getName() + \u0026#34;] is not of type ConfigurableWebApplicationContext\u0026#34;); } // 通过反射创建 IOC 容器对象  ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); // 设置父容器  wac.setParent(parent); String configLocation = getContextConfigLocation(); if (configLocation != null) { wac.setConfigLocation(configLocation); } configureAndRefreshWebApplicationContext(wac); return wac; }   c\u0026gt;DispatcherServlet初始化策略 FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac)，此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件\n所在类：org.springframework.web.servlet.DispatcherServlet\n1 2 3 4 5 6 7 8 9 10 11  protected void initStrategies(ApplicationContext context) { initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); }   3、DispatcherServlet调用组件处理请求 a\u0026gt;processRequest() FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法中调用了processRequest(request, response)\n所在类：org.springframework.web.servlet.FrameworkServlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try { // 执行服务，doService()是一个抽象方法，在DispatcherServlet中进行了重写  doService(request, response); } catch (ServletException | IOException ex) { failureCause = ex; throw ex; } catch (Throwable ex) { failureCause = ex; throw new NestedServletException(\u0026#34;Request processing failed\u0026#34;, ex); } finally { resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) { requestAttributes.requestCompleted(); } logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); } }   b\u0026gt;doService() 所在类：org.springframework.web.servlet.DispatcherServlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  @Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception { logRequest(request); // Keep a snapshot of the request attributes in case of an include,  // to be able to restore the original attributes after the include.  Map\u0026lt;String, Object\u0026gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) { attributesSnapshot = new HashMap\u0026lt;\u0026gt;(); Enumeration\u0026lt;?\u0026gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) { String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) { attributesSnapshot.put(attrName, request.getAttribute(attrName)); } } } // Make framework objects available to handlers and view objects.  request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) { FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) { request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); } request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); } RequestPath requestPath = null; if (this.parseRequestPath \u0026amp;\u0026amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) { requestPath = ServletRequestPathUtils.parseAndCache(request); } try { // 处理请求和响应  doDispatch(request, response); } finally { if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { // Restore the original attribute snapshot, in case of an include.  if (attributesSnapshot != null) { restoreAttributesAfterInclude(request, attributesSnapshot); } } if (requestPath != null) { ServletRequestPathUtils.clearParsedRequestPath(request); } } }   c\u0026gt;doDispatch() 所在类：org.springframework.web.servlet.DispatcherServlet\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception { HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try { ModelAndView mv = null; Exception dispatchException = null; try { processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request.  /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) { noHandlerFound(processedRequest, response); return; } // Determine handler adapter for the current request.  // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法  HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler.  String method = request.getMethod(); boolean isGet = \u0026#34;GET\u0026#34;.equals(method); if (isGet || \u0026#34;HEAD\u0026#34;.equals(method)) { long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) \u0026amp;\u0026amp; isGet) { return; } } // 调用拦截器的preHandle()  if (!mappedHandler.applyPreHandle(processedRequest, response)) { return; } // Actually invoke the handler.  // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象  mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) { return; } applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle()  mappedHandler.applyPostHandle(processedRequest, response, mv); } catch (Exception ex) { dispatchException = ex; } catch (Throwable err) { // As of 4.3, we\u0026#39;re processing Errors thrown from handler methods as well,  // making them available for @ExceptionHandler methods and other scenarios.  dispatchException = new NestedServletException(\u0026#34;Handler dispatch failed\u0026#34;, err); } // 后续处理：处理模型数据和渲染视图  processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); } catch (Exception ex) { triggerAfterCompletion(processedRequest, response, mappedHandler, ex); } catch (Throwable err) { triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\u0026#34;Handler processing failed\u0026#34;, err)); } finally { if (asyncManager.isConcurrentHandlingStarted()) { // Instead of postHandle and afterCompletion  if (mappedHandler != null) { mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); } } else { // Clean up any resources used by a multipart request.  if (multipartRequestParsed) { cleanupMultipart(processedRequest); } } } }   d\u0026gt;processDispatchResult() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception { boolean errorView = false; if (exception != null) { if (exception instanceof ModelAndViewDefiningException) { logger.debug(\u0026#34;ModelAndViewDefiningException encountered\u0026#34;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); } else { Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); } } // Did the handler return a view to render?  if (mv != null \u0026amp;\u0026amp; !mv.wasCleared()) { // 处理模型数据和渲染视图  render(mv, request, response); if (errorView) { WebUtils.clearErrorRequestAttributes(request); } } else { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;No view rendering, null ModelAndView returned.\u0026#34;); } } if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) { // Concurrent handling started during a forward  return; } if (mappedHandler != null) { // Exception (if any) is already handled..  // 调用拦截器的afterCompletion()  mappedHandler.triggerAfterCompletion(request, response, null); } }   4、SpringMVC的执行流程   用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。\n  DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射：\n  a) 不存在\ni. 再判断是否配置了mvc:default-servlet-handler\nii. 如果没配置，则控制台报映射查找不到，客户端展示404错误\niii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误\nb) 存在则执行下面的流程\n 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。\n  DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。\n  如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】\n  提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：\n  a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息\nb) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等\nc) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等\nd) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中\n Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。\n  此时将开始执行拦截器的postHandle(\u0026hellip;)方法【逆向】。\n  根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。\n  渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。\n  将渲染结果返回给客户端。\n  ","date":"2022-05-06T15:55:26+08:00","image":"https://vigorwei.github.io/p/springmvc/cover_hu3266ec263d4dfb86f8dbbb8ea440c63d_248594_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/springmvc/","title":"SpringMVC"},{"content":"next数组构建\n快速构建next数组，是KMP算法的精髓所在，核心思想是“P自己与自己做匹配”。 为什么这样说呢？回顾next数组的完整定义：\n 定义 “k-前缀” 为一个字符串的前 k 个字符； “k-后缀” 为一个字符串的后 k 个字符。k 必须小于字符串长度。 next定义为： P[0]~P这一段字符串，使得k-前缀恰等于k-后缀的最大的k.  　这个定义中，不知不觉地就包含了一个匹配——前缀和后缀相等。接下来，我们考虑采用递推的方式求出next数组。如果next[0], next[1], \u0026hellip; next[x-1]均已知，那么如何求出 next[x] 呢？\n　来分情况讨论。首先，已经知道了 next[x-1]（以下记为now），如果 P[x] 与 P[now] 一样，那最长相等前后缀的长度就可以扩展一位，很明显 next[x] = now + 1\n刚刚解决了 P[x] = P[now] 的情况。那如果 P[x] 与 P[now] 不一样，又该怎么办？\n如图。长度为 now 的子串 A 和子串 B 是 P[0]~P[x-1] 中最长的公共前后缀。可惜 A 右边的字符和 B 右边的那个字符不相等，next[x]不能改成 now+1 了。因此，我们应该缩短这个now，把它改成小一点的值，再来试试 P[x] 是否等于 P[now]. now该缩小到多少呢？显然，我们不想让now缩小太多。因此我们决定，在保持“P[0]~P[x-1]的now-前缀仍然等于now-后缀”的前提下，让这个新的now尽可能大一点。 P[0]~P[x-1] 的公共前后缀，前缀一定落在串A里面、后缀一定落在串B里面。换句话讲：接下来now应该改成：使得 A的k-前缀等于B的k-后缀 的最大的k. 您应该已经注意到了一个非常强的性质——串A和串B是相同的！B的后缀等于A的后缀！因此，使得A的k-前缀等于B的k-后缀的最大的k，其实就是串A的最长公共前后缀的长度 —— next[now-1]！\n来看上面的例子。当P[now]与P[x]不相等的时候，我们需要缩小now——把now变成next[now-1]，直到P[now]=P[x]为止。P[now]=P[x]时，就可以直接向右扩展了。\n附上一个例题\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  class Solution { public int strStr(String haystack, String needle) { if(needle.length()==0) return 0; int[] next = new int[needle.length()]; getNext(next,needle); int j=0; for(int i=0;i\u0026lt;haystack.length();i++){ while(j\u0026gt;0\u0026amp;\u0026amp;haystack.charAt(i)!=needle.charAt(j)){ j=next[j-1]; } if(haystack.charAt(i)==needle.charAt(j)) j++; if(j==needle.length()) return i-j+1; } return -1; } public void getNext(int[] next, String needle){ int j=0; next[0] = 0; for(int i=1;i\u0026lt;needle.length();i++){ while(j\u0026gt;0\u0026amp;\u0026amp;needle.charAt(i)!=needle.charAt(j)){ j = next[j-1]; } if(needle.charAt(i)==needle.charAt(j)) j++; next[i] = j; } } }   ","date":"2022-04-02T09:01:28+08:00","image":"https://vigorwei.github.io/p/kmp/luca-bravo-alS7ewQ41M8-unsplash_hu0a3f1163de68d0b9471979ebf0ecf11e_32400_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/kmp/","title":"KMP"},{"content":"二维数组赋值 1 2 3 4  arr = new char[n][n]; for(char[]c : arr){ Arrays.fill(c,\u0026#39;.\u0026#39;); }   二维数组转List 1 2 3 4 5 6 7  public List\u0026lt;String\u0026gt; Array2List(char[][] arr){ List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(char[]c : arr){ list.add(String.copyValueOf(c)); } }   StringBuilder和StringBuffer相关API\n1 2 3 4  1. public void setCharAt(int pos, char c); 2. str.Append(“a”); 3. sb.deleteCharAt(sb.length() - 1); 4. sb.remove(sb.size() - 1);   数组转字符串 1  new String(arr)   栈和队列的api 1 2 3  stack = new Stack\u0026lt;\u0026gt;():pop(),push(),peek(),isEmpty(); Queue=new LinkedList\u0026lt;\u0026gt;():offer(),poll(),peek,isEmpty(),pollLast(),q.getFirst();   List 1 2 3 4 5 6 7 8 9 10 11 12  String a=\u0026#34;白龙马\u0026#34;, b=\u0026#34;沙和尚\u0026#34;, c=\u0026#34;八戒\u0026#34;, d=\u0026#34;唐僧\u0026#34;, e=\u0026#34;悟空\u0026#34;; List\u0026lt;String\u0026gt; people=new ArrayList\u0026lt;\u0026gt;(); people.add(a); people.add(b); people.add(c); people.set(0, d); //.set(index, element); //将d唐僧放到list中索引为0的位置，替换a白龙马 people.add(1, e); //.add(index, element); //将e悟空放到list中索引为1的位置,原来位置的b沙和尚后移一位 //增强for循环遍历list for(String str:people){ System.out.println(str); }   位操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  # bit操作 \u0026amp; 符号，x \u0026amp; y ，会将两个十进制数在二进制下进行与运算 | 符号，x | y ，会将两个十进制数在二进制下进行或运算 ^ 符号，x ^ y ，会将两个十进制数在二进制下进行异或运算 \u0026lt;\u0026lt; 符号，x \u0026lt;\u0026lt; y 左移操作，最右边用 0 填充 \u0026gt;\u0026gt; 符号，x \u0026gt;\u0026gt; y 右移操作，最左边用 0 填充 ~ 符号，~x ，按位取反操作，将 x 在二进制下的每一位取反 # 整数集合set位运算 # 整数集合做标志时，比如回溯时的visited标志数组 vstd 访问 i ：vstd | (1 \u0026lt;\u0026lt; i) vstd 离开 i ：vstd \u0026amp; ~(1 \u0026lt;\u0026lt; i) vstd 不包含 i : not vstd \u0026amp; (1 \u0026lt;\u0026lt; i) 并集 ：A | B 交集 ：A \u0026amp; B 全集 ：(1 \u0026lt;\u0026lt; n) - 1 补集 ：((1 \u0026lt;\u0026lt; n) - 1) ^ A 子集 ：(A \u0026amp; B) == B 判断是否是 2 的幂 ：A \u0026amp; (A - 1) == 0 最低位的 1 变为 0 ：n \u0026amp;= (n - 1) 最低位的 1：A \u0026amp; (-A)，最低位的 1 一般记为 lowbit(A)   ","date":"2022-03-17T11:14:11+08:00","permalink":"https://vigorwei.github.io/p/java-api/","title":"Java Api"},{"content":"Spring-AOP 1、AOP 基本概念 （1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n（2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能\n（3）使用登录例子说明 AOP\n2、AOP（底层原理） a）AOP 底层使用动态代理 ，动态代理有两种情况：\n第一种 有接口情况，使用 JDK 动态代理 ；创建接口实现类代理对象，增强类的方法\n第二种 没有接口情况，使用 CGLIB 动态代理；创建子类的代理对象，增强类的方法\n3、AOP（JDK 动态代理） 1）使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象\n1 2 3 4 5 6 7 8  public static Object newProxyInstance(ClassLoader loader, Class\u0026lt;?\u0026gt;[] interfaces, InvocationHandler h) ​ 第一参数，类加载器 ​ 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口 ​ 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分   2）编写 JDK 动态代理代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  //（1）创建接口，定义方法 public interface UserDao { public int add(int a,int b); public String update(String id); } //（2）创建接口实现类，实现方法 public class UserDaoImpl implements UserDao { @Override public int add(int a, int b) { return a+b; } @Override public String update(String id) { return id; } } //（3）使用 Proxy 类创建接口代理对象 public class JDKProxy { public static void main(String[] args) { //创建接口实现类代理对象 Class[] interfaces = {UserDao.class}; UserDaoImpl userDao = new UserDaoImpl(); /** 第一参数，类加载器 第二参数，增强方法所在的类，这个类实现的接口，(支持多个接口) 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分 */ UserDao dao =(UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); int result = dao.add(1, 2); System.out.println(\u0026#34;result:\u0026#34;+result); } } //创建代理对象代码 class UserDaoProxy implements InvocationHandler { //1 把创建的是谁的代理对象，把谁传递过来 //有参数构造传递 private Object obj; public UserDaoProxy(Object obj) { this.obj = obj; } //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //方法之前 System.out.println(\u0026#34;方法之前执行....\u0026#34;+method.getName()+\u0026#34; :传递的参数...\u0026#34;+ Arrays.toString(args)); //被增强的方法执行 Object res = method.invoke(obj, args); //方法之后 System.out.println(\u0026#34;方法之后执行....\u0026#34;+obj); return res; } }   4、AOP（术语） a）连接点：类里面哪些方法可以被增强，这些方法称为连接点\nb）切入点：实际被真正增强的方法称为切入点\nc）通知（增强）：实际增强的逻辑部分称为通知，且分为以下五种类型：\n1）前置通知 2）后置通知 3）环绕通知 4）异常通知 5）最终通知\nd）切面：把通知应用到切入点过程\n5、AOP操作 a）Spring 框架一般都是基于 AspectJ 实现 AOP 操作，AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作\nb）基于 AspectJ 实现 AOP 操作：1）基于 xml 配置文件实现 （2）基于注解方式实现（使用）\nc）引入相关jar包\nd）切入点表达式，如下\n1 2 3 4 5 6 7 8 9  （1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强 （2）语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) ) （3）例子如下： 例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 execution(* com.atguigu.dao.BookDao.add(..)) 例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 execution(* com.atguigu.dao.BookDao.* (..)) 例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 execution(* com.atguigu.dao.*.* (..))   6、AOP 操作（AspectJ 注解） 1 2 3 4 5 6 7 8 9 10 11 12 13 14  //1、创建类，在类里面定义方法 public class User { public void add() { System.out.println(\u0026#34;add.......\u0026#34;); } } //2、创建增强类（编写增强逻辑） //（1）在增强类里面，创建方法，让不同方法代表不同通知类型 //增强的类 public class UserProxy { public void before() {//前置通知 System.out.println(\u0026#34;before......\u0026#34;); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!--3、进行通知的配置--\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!-- 开启注解扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu.spring5.aopanno\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 开启Aspect生成代理对象--\u0026gt; \u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt; \u0026lt;/beans\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  //增强的类 @Component @Aspect //生成代理对象 public class UserProxy {} //被增强的类 @Component public class User {} //4、配置不同类型的通知 @Component @Aspect //生成代理对象 public class UserProxy { //相同切入点抽取 @Pointcut(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void pointdemo() { } //前置通知 //@Before注解表示作为前置通知 @Before(value = \u0026#34;pointdemo()\u0026#34;)//相同切入点抽取使用！ public void before() { System.out.println(\u0026#34;before.........\u0026#34;); } //后置通知（返回通知） @AfterReturning(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void afterReturning() { System.out.println(\u0026#34;afterReturning.........\u0026#34;); } //最终通知 @After(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void after() { System.out.println(\u0026#34;after.........\u0026#34;); } //异常通知 @AfterThrowing(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void afterThrowing() { System.out.println(\u0026#34;afterThrowing.........\u0026#34;); } //环绕通知 @Around(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(\u0026#34;环绕之前.........\u0026#34;); //被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(\u0026#34;环绕之后.........\u0026#34;); } }   7、有多个增强类对同一个方法进行增强，设置增强类优先级 1 2 3 4 5  //（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 @Component @Aspect @Order(1) public class PersonProxy{ }   8、AOP 操作（AspectJ 配置文件） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!--1、创建两个类，增强类和被增强类，创建方法（同上一样）--\u0026gt; \u0026lt;!--2、在 spring 配置文件中创建两个类对象--\u0026gt; \u0026lt;!--创建对象--\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.aopxml.Book\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;bookProxy\u0026#34; class=\u0026#34;com.atguigu.spring5.aopxml.BookProxy\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--3、在 spring 配置文件中配置切入点--\u0026gt; \u0026lt;!--配置 aop 增强--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;p\u0026#34; expression=\u0026#34;execution(* com.atguigu.spring5.aopxml.Book.buy(..))\u0026#34;/\u0026gt; \u0026lt;!--配置切面--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;bookProxy\u0026#34;\u0026gt; \u0026lt;!--增强作用在具体的方法上--\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;p\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt;   ","date":"2022-03-16T15:47:13+08:00","image":"https://vigorwei.github.io/p/sping5-aop/cover-v1.2.0_hu27a756884c7e9dfb9cbdf758af038fda_343566_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/sping5-aop/","title":"Sping5 Aop"},{"content":"IOC 操作 Bean 管理(基于注解方式) 1、什么是注解 （1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值…)\n（2）使用注解，注解作用在类上面，方法上面，属性上面\n（3）使用注解目的：简化 xml 配置\n2、Spring 针对 Bean 管理中创建对象提供注解 下面四个注解功能是一样的，都可以用来创建 bean 实例\n（1）@Component\n（2）@Service\n（3）@Controller\n（4）@Repository\n3、基于注解方式实现对象创建 第一步 引入依赖 （引入spring-aop jar包）\n第二步 开启组件扫描\n1 2 3 4 5  \u0026lt;!--开启组件扫描 1 如果扫描多个包，多个包使用逗号隔开 2 扫描包上层目录 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt;   第三步 创建类，在类上面添加创建对象注解\n1 2 3 4 5 6 7 8 9  //在注解里面 value 属性值可以省略不写， //默认值是类名称，首字母小写 //UserService -- userService @Component(value = \u0026#34;userService\u0026#34;) //注解等同于XML配置文件：\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;..\u0026#34;/\u0026gt; public class UserService { public void add() { System.out.println(\u0026#34;service add.......\u0026#34;); } }   4、开启组件扫描细节配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!--示例 1 use-default-filters=\u0026#34;false\u0026#34; 表示现在不使用默认 filter，自己配置 filter context:include-filter ，设置扫描哪些内容 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu\u0026#34; use-defaultfilters=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;context:include-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt;\u0026lt;!--代表只扫描Controller注解的类--\u0026gt; \u0026lt;/context:component-scan\u0026gt; \u0026lt;!--示例 2 下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt;\u0026lt;!--表示Controller注解的类之外一切都进行扫描--\u0026gt; \u0026lt;/context:component-scan\u0026gt;   5、基于注解方式实现属性注入 （1）@Autowired：根据属性类型进行自动装配\n第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解\n第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Service public class UserService { //定义 dao 类型属性 //不需要添加 set 方法 //添加注入属性注解 @Autowired private UserDao userDao; public void add() { System.out.println(\u0026#34;service add.......\u0026#34;); userDao.add(); } } //Dao实现类 @Repository //@Repository(value = \u0026#34;userDaoImpl1\u0026#34;) public class UserDaoImpl implements UserDao { @Override public void add() { System.out.println(\u0026#34;dao add.....\u0026#34;); } }   （2）@Qualifier：根据名称进行注入，这个@Qualifier 注解的使用，和上面@Autowired 一起使用\n1 2 3 4 5 6 7  //定义 dao 类型属性 //不需要添加 set 方法 //添加注入属性注解 @Autowired //根据类型进行注入 //根据名称进行注入（目的在于区别同一接口下有多个实现类，根据类型就无法选择，从而出错！） @Qualifier(value = \u0026#34;userDaoImpl1\u0026#34;) private UserDao userDao;   （3）@Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）\n1 2 3  //@Resource //根据类型进行注入 @Resource(name = \u0026#34;userDaoImpl1\u0026#34;) //根据名称进行注入 private UserDao userDao;   （4）@Value：注入普通类型属性\n1 2  @Value(value = \u0026#34;abc\u0026#34;) private String name   6、完全注解开发 （1）创建配置类，替代 xml 配置文件\n1 2 3 4 5  @Configuration //作为配置类，替代 xml 配置文件 @ComponentScan(basePackages = {\u0026#34;com.atguigu\u0026#34;}) public class SpringConfig { }   （2）编写测试类\n1 2 3 4 5 6 7 8 9 10  @Test public void testService2() { //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(\u0026#34;userService\u0026#34;, UserService.class); System.out.println(userService); userService.add(); }   ","date":"2022-03-14T20:17:57+08:00","image":"https://vigorwei.github.io/p/spring5-ioc%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/cover-v1.2.0_hu27a756884c7e9dfb9cbdf758af038fda_343566_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/spring5-ioc%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/","title":"Spring5-IOC注解方式"},{"content":"Spring——IOC（控制反转） 一、IOC容器 1、什么是IOC（控制反转） a）把对象创建和对象之间的调用过程，交给Spring进行管理\nb）使用IOC目的：为了降低耦合度\n2、IOC底层 a）xml解析、工厂模式、反射\n3、Spring提供的IOC容器实现的两种方式（两个接口） a）BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。）\nb）ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！\n4、ApplicationContext接口的实现类（具体根据API文档查看☺） 二、IOC容器-Bean管理 1、IOC操作Bean管理 a）Bean管理就是两个操作：（1）Spring创建对象；（2）Spring注入属性\n2、基于XML配置文件创建对象 1 2  \u0026lt;!--1 配置User对象创建--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.atguigu.spring5.User\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;   3、基于XML方式注入属性（DI：依赖注入（注入属性）） a）set方式注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  //（1）传统方式： 创建类，定义属性和对应的set方法 public class Book { //创建属性 private String bname; //创建属性对应的set方法 public void setBname(String bname) { this.bname = bname; } } \u0026lt;!--（2）spring方式： set方法注入属性--\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.Book\u0026#34;\u0026gt; \u0026lt;!--使用property完成属性注入 name：类里面属性名称 value：向属性注入的值 --\u0026gt; \u0026lt;property name=\u0026#34;bname\u0026#34; value=\u0026#34;Hello\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;bauthor\u0026#34; value=\u0026#34;World\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   b）有参构造函数注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //（1）传统方式：创建类，构建有参函数 public class Orders { //属性 private String oname; private String address; //有参数构造 public Orders(String oname,String address) { this.oname = oname; this.address = address; } } \u0026lt;!--（2）spring方式：有参数构造注入属性--\u0026gt; \u0026lt;bean id=\u0026#34;orders\u0026#34; class=\u0026#34;com.atguigu.spring5.Orders\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;oname\u0026#34; value=\u0026#34;Hello\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;address\u0026#34; value=\u0026#34;China！\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt;   c）p名称空间注入（了解即可）\n1 2 3 4 5 6 7 8 9  \u0026lt;!--1、添加p名称空间在配置文件头部--\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34;\t\u0026lt;!--在这里添加一行p--\u0026gt; \u0026lt;!--2、在bean标签进行属性注入（算是set方式注入的简化操作）--\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.Book\u0026#34; p:bname=\u0026#34;very\u0026#34; p:bauthor=\u0026#34;good\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt;   4、注入空值和特殊符号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.Book\u0026#34;\u0026gt; \u0026lt;!--（1）null值--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34;\u0026gt; \u0026lt;null/\u0026gt;\u0026lt;!--属性里边添加一个null标签--\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--（2）特殊符号赋值--\u0026gt; \u0026lt;!--属性值包含特殊符号 a 把\u0026lt;\u0026gt;进行转义 \u0026amp;lt; \u0026amp;gt; b 把带特殊符号内容写到CDATA --\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34;\u0026gt; \u0026lt;value\u0026gt;\u0026lt;![CDATA[\u0026lt;\u0026lt;南京\u0026gt;\u0026gt;]]\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   5、注入属性-外部bean a）创建两个类service和dao类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class UserService {//service类 //创建UserDao类型属性，生成set方法 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add() { System.out.println(\u0026#34;service add...............\u0026#34;); userDao.update();//调用dao方法 } } public class UserDaoImpl implements UserDao {//dao类 @Override public void update() { System.out.println(\u0026#34;dao update...........\u0026#34;); } }   b）在spring配置文件中进行配置\n1 2 3 4 5 6 7 8 9  \u0026lt;!--1 service和dao对象创建--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.atguigu.spring5.service.UserService\u0026#34;\u0026gt; \u0026lt;!--注入userDao对象 name属性：类里面属性名称 ref属性：创建userDao对象bean标签id值 --\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDaoImpl\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userDaoImpl\u0026#34; class=\u0026#34;com.atguigu.spring5.dao.UserDaoImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;   6、基于XML方式注入内部bean和级联赋值 a）注入属性-内部bea\n（1）一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门（部门是一，员工是多） （2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //部门类 public class Dept { private String dname; public void setDname(String dname) { this.dname = dname; } } //员工类 public class Emp { private String ename; private String gender; //员工属于某一个部门，使用对象形式表示 private Dept dept; public void setDept(Dept dept) { this.dept = dept; } public void setEname(String ename) { this.ename = ename; } public void setGender(String gender) { this.gender = gender; } }   （3）在spring配置文件中配置\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!--内部bean--\u0026gt; \u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Emp\u0026#34;\u0026gt; \u0026lt;!--设置两个普通属性--\u0026gt; \u0026lt;property name=\u0026#34;ename\u0026#34; value=\u0026#34;Andy\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--设置对象类型属性--\u0026gt; \u0026lt;property name=\u0026#34;dept\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;dept\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Dept\u0026#34;\u0026gt;\u0026lt;!--内部bean赋值--\u0026gt; \u0026lt;property name=\u0026#34;dname\u0026#34; value=\u0026#34;宣传部门\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   b）注入属性-级联赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;!--方式一：级联赋值--\u0026gt; \u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Emp\u0026#34;\u0026gt; \u0026lt;!--设置两个普通属性--\u0026gt; \u0026lt;property name=\u0026#34;ename\u0026#34; value=\u0026#34;Andy\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--级联赋值--\u0026gt; \u0026lt;property name=\u0026#34;dept\u0026#34; ref=\u0026#34;dept\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dept\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Dept\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dname\u0026#34; value=\u0026#34;公关部门\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; //方式二：生成dept的get方法（get方法必须有！！） public Dept getDept() { return dept; } \u0026lt;!--级联赋值--\u0026gt; \u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Emp\u0026#34;\u0026gt; \u0026lt;!--设置两个普通属性--\u0026gt; \u0026lt;property name=\u0026#34;ename\u0026#34; value=\u0026#34;jams\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--级联赋值--\u0026gt; \u0026lt;property name=\u0026#34;dept\u0026#34; ref=\u0026#34;dept\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;dept.dname\u0026#34; value=\u0026#34;技术部门\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dept\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Dept\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt;   7、IOC 操作 Bean 管理——xml 注入集合属性 1、注入数组类型属性 2、注入 List 集合类型属性 3、注入 Map 集合类型属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法 public class Stu { //1 数组类型属性 private String[] courses; //2 list集合类型属性 private List\u0026lt;String\u0026gt; list; //3 map集合类型属性 private Map\u0026lt;String,String\u0026gt; maps; //4 set集合类型属性 private Set\u0026lt;String\u0026gt; sets; public void setSets(Set\u0026lt;String\u0026gt; sets) { this.sets = sets; } public void setCourses(String[] courses) { this.courses = courses; } public void setList(List\u0026lt;String\u0026gt; list) { this.list = list; } public void setMaps(Map\u0026lt;String, String\u0026gt; maps) { this.maps = maps; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  \u0026lt;!--（2）在 spring 配置文件进行配置--\u0026gt; \u0026lt;bean id=\u0026#34;stu\u0026#34; class=\u0026#34;com.atguigu.spring5.collectiontype.Stu\u0026#34;\u0026gt; \u0026lt;!--数组类型属性注入--\u0026gt; \u0026lt;property name=\u0026#34;courses\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;java课程\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;数据库课程\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--list类型属性注入--\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;张三\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;小三\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--map类型属性注入--\u0026gt; \u0026lt;property name=\u0026#34;maps\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;JAVA\u0026#34; value=\u0026#34;java\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;PHP\u0026#34; value=\u0026#34;php\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--set类型属性注入--\u0026gt; \u0026lt;property name=\u0026#34;sets\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;MySQL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;Redis\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   8、在集合里面设置对象类型值 1 2 3 4 5  //学生所学多门课程 private List\u0026lt;Course\u0026gt; courseList;//创建集合 public void setCourseList(List\u0026lt;Course\u0026gt; courseList) { this.courseList = courseList; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!--创建多个course对象--\u0026gt; \u0026lt;bean id=\u0026#34;course1\u0026#34; class=\u0026#34;com.atguigu.spring5.collectiontype.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cname\u0026#34; value=\u0026#34;Spring5框架\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;course2\u0026#34; class=\u0026#34;com.atguigu.spring5.collectiontype.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cname\u0026#34; value=\u0026#34;MyBatis框架\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--注入list集合类型，值是对象--\u0026gt; \u0026lt;property name=\u0026#34;courseList\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;ref bean=\u0026#34;course1\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;ref bean=\u0026#34;course2\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;!--第一步：在 spring 配置文件中引入名称空间 util--\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:util=\u0026#34;http://www.springframework.org/schema/util\u0026#34; \u0026lt;!--添加util名称空间--\u0026gt; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\u0026#34;\u0026gt; \u0026lt;!--添加util名称空间--\u0026gt; \u0026lt;!--第二步：使用 util 标签完成 list 集合注入提取--\u0026gt; \u0026lt;!--把集合注入部分提取出来--\u0026gt; \u0026lt;!--1 提取list集合类型属性注入--\u0026gt; \u0026lt;util:list id=\u0026#34;bookList\u0026#34;\u0026gt; \u0026lt;value\u0026gt;易筋经\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;九阴真经\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;九阳神功\u0026lt;/value\u0026gt; \u0026lt;/util:list\u0026gt; \u0026lt;!--2 提取list集合类型属性注入使用--\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.collectiontype.Book\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34; ref=\u0026#34;bookList\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   Spring IOC容器-Bean管理——基于XML 1、IOC 操作 Bean 管理（FactoryBean）\n1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）\n2、普通 bean：在配置文件中定义 bean 类型就是返回类型\n3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class MyBean implements FactoryBean\u0026lt;Course\u0026gt; { //定义返回bean @Override public Course getObject() throws Exception { Course course = new Course(); course.setCname(\u0026#34;abc\u0026#34;); return course; } } \u0026lt;bean id=\u0026#34;myBean\u0026#34; class=\u0026#34;com.atguigu.spring5.factorybean.MyBean\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; @Test public void test3() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean3.xml\u0026#34;); Course course = context.getBean(\u0026#34;myBean\u0026#34;, Course.class);//返回值类型可以不是定义的bean类型！ System.out.println(course); }   2、IOC 操作 Bean 管理（bean 作用域）\n在 Spring 里面，默认情况下，bean 是单实例对象，下面进行作用域设置：\n（1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例\n（2）scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象\n（3）singleton 和 prototype 区别\na）singleton 单实例，prototype 多实例\nb）设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 ；设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象\n3、IOC 操作 Bean 管理（bean 生命周期）\n1、生命周期 ：从对象创建到对象销毁的过程\n2、bean 生命周期\n（1）通过构造器创建 bean 实例（无参数构造）\n（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n（3）调用 bean 的初始化的方法（需要进行配置初始化的方法）\n（4）bean 可以使用了（对象获取到了）\n（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n3、演示 bean 生命周期 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  public class Orders { //无参数构造 public Orders() { System.out.println(\u0026#34;第一步 执行无参数构造创建 bean 实例\u0026#34;); } private String oname; public void setOname(String oname) { this.oname = oname; System.out.println(\u0026#34;第二步 调用 set 方法设置属性值\u0026#34;); } //创建执行的初始化的方法 public void initMethod() { System.out.println(\u0026#34;第三步 执行初始化的方法\u0026#34;); } //创建执行的销毁的方法 public void destroyMethod() { System.out.println(\u0026#34;第五步 执行销毁的方法\u0026#34;); } } public class MyBeanPost implements BeanPostProcessor {//创建后置处理器实现类 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;在初始化之前执行的方法\u0026#34;); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;在初始化之后执行的方法\u0026#34;); return bean; } } \u0026lt;!--配置文件的bean参数配置--\u0026gt; \u0026lt;bean id=\u0026#34;orders\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Orders\u0026#34; init-method=\u0026#34;initMethod\u0026#34; destroy-method=\u0026#34;destroyMethod\u0026#34;\u0026gt;\t\u0026lt;!--配置初始化方法和销毁方法--\u0026gt; \u0026lt;property name=\u0026#34;oname\u0026#34; value=\u0026#34;手机\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\u0026lt;!--这里就是通过set方式（注入属性）赋值--\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置后置处理器--\u0026gt; \u0026lt;bean id=\u0026#34;myBeanPost\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.MyBeanPost\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; @Test public void testBean3() { // ApplicationContext context = // new ClassPathXmlApplicationContext(\u0026#34;bean4.xml\u0026#34;); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean4.xml\u0026#34;); Orders orders = context.getBean(\u0026#34;orders\u0026#34;, Orders.class); System.out.println(\u0026#34;第四步 获取创建 bean 实例对象\u0026#34;); System.out.println(orders); //手动让 bean 实例销毁 context.close(); }   4、bean 的后置处理器，bean 生命周期有七步 （正常生命周期为五步，而配置后置处理器后为七步）\n（1）通过构造器创建 bean 实例（无参数构造）\n（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n（3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization\n（4）调用 bean 的初始化的方法（需要进行配置初始化的方法）\n（5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization\n（6）bean 可以使用了（对象获取到了）\n（7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n4、IOC 操作 Bean 管理(外部属性文件) 方式一：直接配置数据库信息 ：（1）配置Druid（德鲁伊）连接池 （2）引入Druid（德鲁伊）连接池依赖 jar 包\n1 2 3 4 5 6 7  \u0026lt;!--直接配置连接池--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/userDb\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   方式二：引入外部属性文件配置数据库连接池\n（1）创建外部属性文件，properties 格式文件，写数据库信息（jdbc.properties）\n1 2 3 4  prop.driverClass=com.mysql.jdbc.Driver prop.url=jdbc:mysql://localhost:3306/userDb prop.userName=root prop.password=root   （2）把外部 properties 属性文件引入到 spring 配置文件中 —— 引入 context 名称空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt;\u0026lt;!--引入context名称空间--\u0026gt; \u0026lt;!--引入外部属性文件--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;!--配置连接池--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${prop.driverClass}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${prop.url}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${prop.userName}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${prop.password}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   ","date":"2022-03-14T19:25:09+08:00","image":"https://vigorwei.github.io/p/spring5-ioc-xml%E6%96%B9%E5%BC%8F/cover-v1.2.0_hu27a756884c7e9dfb9cbdf758af038fda_343566_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/spring5-ioc-xml%E6%96%B9%E5%BC%8F/","title":"Spring5-IOC XML方式"},{"content":"Mybatis简介 MyBatis历史  MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）  MyBatis特性  MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架  MyBatis下载  MyBatis下载地址   和其它持久化层技术对比  JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤  维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低   Hibernate 和 JPA 操作简便，开发效率高  程序中的长难复杂 SQL 需要绕过框架 内部自动生产的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 反射操作太多，导致数据库性能下降   MyBatis 轻量级，性能出色  SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于HIbernate，但是完全能够接受    搭建MyBatis 开发环境  IDE：idea 2019.2 构建工具：maven 3.5.4 MySQL版本：MySQL 5.7 MyBatis版本：MyBatis 3.5.7  创建maven工程   打包方式：jar\n  引入依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;dependencies\u0026gt; \u0026lt;!-- Mybatis核心 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit测试 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySQL驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;        创建MyBatis的核心配置文件  习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息 核心配置文件存放的位置是src/main/resources目录下\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--设置连接数据库的环境--\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/MyBatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--引入映射文件--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   创建mapper接口  MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类\n 1 2 3 4 5 6 7 8  package com.atguigu.mybatis.mapper; public interface UserMapper { /** * 添加用户信息 */ int insertUser(); }   创建MyBatis的映射文件  相关概念：ORM（Object Relationship Mapping）对象关系映射。 对象：Java的实体类对象  关系：关系型数据库 映射：二者之间的对应关系       Java概念 数据库概念     类 表   属性 字段/列   对象 记录/行     映射文件的命名规则 表所对应的实体类的类名+Mapper.xml  例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src/main/resources/mappers目录下   MyBatis中可以面向接口操作数据，要保证两个一致 mapper接口的全类名和映射文件的命名空间（namespace）保持一致  mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致    1 2 3 4 5 6 7 8 9 10  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.atguigu.mybatis.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;!--int insertUser();--\u0026gt; \u0026lt;insert id=\u0026#34;insertUser\u0026#34;\u0026gt; insert into t_user values(null,\u0026#39;张三\u0026#39;,\u0026#39;123\u0026#39;,23,\u0026#39;女\u0026#39;) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt;   通过junit测试功能  SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话） SqlSessionFactory：是“生产”SqlSession的“工厂” 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class UserMapperTest { @Test public void testInsertUser() throws IOException { //读取MyBatis的核心配置文件  InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); //获取SqlSessionFactoryBuilder对象  SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象  SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务  //SqlSession sqlSession = sqlSessionFactory.openSession(); \t//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交 \tSqlSession sqlSession = sqlSessionFactory.openSession(true); //通过代理模式创建UserMapper接口的代理实现类对象  UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句  int result = userMapper.insertUser(); //提交事务  //sqlSession.commit();  System.out.println(\u0026#34;result:\u0026#34; + result); } }    此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用SqlSession sqlSession = sqlSessionFactory.openSession(true);，传入一个Boolean类型的参数，值为true，这样就可以自动提交  加入log4j日志功能   加入依赖\n1 2 3 4 5 6  \u0026lt;!-- log4j日志 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     加入log4j的配置文件\n log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下 日志的级别：FATAL(致命)\u0026gt;ERROR(错误)\u0026gt;WARN(警告)\u0026gt;INFO(信息)\u0026gt;DEBUG(调试) 从左到右打印的内容越来越详细  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE log4j:configuration SYSTEM \u0026#34;log4j.dtd\u0026#34;\u0026gt; \u0026lt;log4j:configuration xmlns:log4j=\u0026#34;http://jakarta.apache.org/log4j/\u0026#34;\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;org.apache.log4j.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;Encoding\u0026#34; value=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;layout class=\u0026#34;org.apache.log4j.PatternLayout\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;ConversionPattern\u0026#34; value=\u0026#34;%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n\u0026#34; /\u0026gt; \u0026lt;/layout\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;logger name=\u0026#34;java.sql\u0026#34;\u0026gt; \u0026lt;level value=\u0026#34;debug\u0026#34; /\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;org.apache.ibatis\u0026#34;\u0026gt; \u0026lt;level value=\u0026#34;info\u0026#34; /\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;root\u0026gt; \u0026lt;level value=\u0026#34;debug\u0026#34; /\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/log4j:configuration\u0026gt;     核心配置文件详解  核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)： properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//MyBatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://MyBatis.org/dtd/MyBatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--\u0026gt; \u0026lt;properties resource=\u0026#34;jdbc.properties\u0026#34;\u0026gt;\u0026lt;/properties\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!--将表中字段的下划线自动转换为驼峰--\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!--开启延迟加载--\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名 --\u0026gt; \u0026lt;!--\u0026lt;typeAlias type=\u0026#34;com.atguigu.mybatis.bean.User\u0026#34;\u0026gt;\u0026lt;/typeAlias\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;typeAlias type=\u0026#34;com.atguigu.mybatis.bean.User\u0026#34; alias=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;/typeAlias\u0026gt;--\u0026gt; \u0026lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--\u0026gt; \u0026lt;package name=\u0026#34;com.atguigu.mybatis.bean\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --\u0026gt; \u0026lt;environments default=\u0026#34;mysql_test\u0026#34;\u0026gt; \u0026lt;!-- environment：设置具体的连接数据库的环境信息 属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境 --\u0026gt; \u0026lt;environment id=\u0026#34;mysql_test\u0026#34;\u0026gt; \u0026lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=\u0026#34;JDBC|MANAGED\u0026#34; type=\u0026#34;JDBC\u0026#34;：设置当前环境的事务管理都必须手动处理 type=\u0026#34;MANAGED\u0026#34;：设置事务被管理，例如spring中的AOP --\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=\u0026#34;POOLED|UNPOOLED|JNDI\u0026#34; type=\u0026#34;POOLED\u0026#34;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建 type=\u0026#34;UNPOOLED\u0026#34;：不使用数据库连接池，即每次使用连接都需要重新创建 type=\u0026#34;JNDI\u0026#34;：调用上下文中的数据源 --\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;!--设置驱动类的全类名--\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;!--设置连接数据库的连接地址--\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;!--设置连接数据库的用户名--\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;!--设置连接数据库的密码--\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--引入映射文件--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;!-- \u0026lt;mapper resource=\u0026#34;UserMapper.xml\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意： 1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下 2. mapper接口要和mapper映射文件的名字一致 --\u0026gt; \u0026lt;package name=\u0026#34;com.atguigu.mybatis.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;      默认的类型别名 MyBatis的增删改查   添加\n1 2 3 4  \u0026lt;!--int insertUser();--\u0026gt; \u0026lt;insert id=\u0026#34;insertUser\u0026#34;\u0026gt; insert into t_user values(null,\u0026#39;admin\u0026#39;,\u0026#39;123456\u0026#39;,23,\u0026#39;男\u0026#39;,\u0026#39;12345@qq.com\u0026#39;) \u0026lt;/insert\u0026gt;     删除\n1 2 3 4  \u0026lt;!--int deleteUser();--\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34;\u0026gt; delete from t_user where id = 6 \u0026lt;/delete\u0026gt;     修改\n1 2 3 4  \u0026lt;!--int updateUser();--\u0026gt; \u0026lt;update id=\u0026#34;updateUser\u0026#34;\u0026gt; update t_user set username = \u0026#39;张三\u0026#39; where id = 5 \u0026lt;/update\u0026gt;     查询一个实体类对象\n1 2 3 4  \u0026lt;!--User getUserById();--\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; resultType=\u0026#34;com.atguigu.mybatis.bean.User\u0026#34;\u0026gt; select * from t_user where id = 2 \u0026lt;/select\u0026gt;     查询集合\n1 2 3 4  \u0026lt;!--List\u0026lt;User\u0026gt; getUserList();--\u0026gt; \u0026lt;select id=\u0026#34;getUserList\u0026#34; resultType=\u0026#34;com.atguigu.mybatis.bean.User\u0026#34;\u0026gt; select * from t_user \u0026lt;/select\u0026gt;       注意：\n 查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况   当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值    MyBatis获取参数值的两种方式（重点）  MyBatis获取参数值的两种方式：${}和#{} ${}的本质就是字符串拼接，#{}的本质就是占位符赋值 ${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号  单个字面量类型的参数  若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号  1 2 3 4  \u0026lt;!--User getUserByUsername(String username);--\u0026gt; \u0026lt;select id=\u0026#34;getUserByUsername\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = #{username} \u0026lt;/select\u0026gt;   1 2 3 4  \u0026lt;!--User getUserByUsername(String username);--\u0026gt; \u0026lt;select id=\u0026#34;getUserByUsername\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = \u0026#39;${username}\u0026#39; \u0026lt;/select\u0026gt;   多个字面量类型的参数   若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中\n 以arg0,arg1\u0026hellip;为键，以参数为值； 以param1,param2\u0026hellip;为键，以参数为值；    因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。\n  使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的\n  1 2 3 4  \u0026lt;!--User checkLogin(String username,String password);--\u0026gt; \u0026lt;select id=\u0026#34;checkLogin\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = #{arg0} and password = #{arg1} \u0026lt;/select\u0026gt;   1 2 3 4  \u0026lt;!--User checkLogin(String username,String password);--\u0026gt; \u0026lt;select id=\u0026#34;checkLogin\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = \u0026#39;${param1}\u0026#39; and password = \u0026#39;${param2}\u0026#39; \u0026lt;/select\u0026gt;   map集合类型的参数  若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号  1 2 3 4  \u0026lt;!--User checkLoginByMap(Map\u0026lt;String,Object\u0026gt; map);--\u0026gt; \u0026lt;select id=\u0026#34;checkLoginByMap\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = #{username} and password = #{password} \u0026lt;/select\u0026gt;   1 2 3 4 5 6 7 8 9 10  @Test public void checkLoginByMap() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;usermane\u0026#34;,\u0026#34;admin\u0026#34;); map.put(\u0026#34;password\u0026#34;,\u0026#34;123456\u0026#34;); User user = mapper.checkLoginByMap(map); System.out.println(user); }   实体类类型的参数  若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号  1 2 3 4  \u0026lt;!--int insertUser(User user);--\u0026gt; \u0026lt;insert id=\u0026#34;insertUser\u0026#34;\u0026gt; insert into t_user values(null,#{username},#{password},#{age},#{sex},#{email}) \u0026lt;/insert\u0026gt;   1 2 3 4 5 6 7  @Test public void insertUser() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); User user = new User(null,\u0026#34;Tom\u0026#34;,\u0026#34;123456\u0026#34;,12,\u0026#34;男\u0026#34;,\u0026#34;123@321.com\u0026#34;); mapper.insertUser(user); }   使用@Param标识参数   可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中\n 以@Param注解的value属性值为键，以参数为值； 以param1,param2\u0026hellip;为键，以参数为值；    只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号\n  1 2 3 4  \u0026lt;!--User CheckLoginByParam(@Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password);--\u0026gt; \u0026lt;select id=\u0026#34;CheckLoginByParam\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = #{username} and password = #{password} \u0026lt;/select\u0026gt;   1 2 3 4 5 6  @Test public void checkLoginByParam() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); mapper.CheckLoginByParam(\u0026#34;admin\u0026#34;,\u0026#34;123456\u0026#34;); }   总结   建议分成两种情况进行处理\n 实体类类型的参数 使用@Param标识参数    MyBatis的各种查询功能  如果查询出的数据只有一条，可以通过  实体类对象接收 List集合接收 Map集合接收，结果{password=123456, sex=男, id=1, age=23, username=admin}   如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过  实体类类型的LIst集合接收 Map类型的LIst集合接收 在mapper接口的方法上添加@MapKey注解    查询一个实体类对象 1 2 3 4 5 6  /** * 根据用户id查询用户信息 * @param id * @return */ User getUserById(@Param(\u0026#34;id\u0026#34;) int id);   1 2 3 4  \u0026lt;!--User getUserById(@Param(\u0026#34;id\u0026#34;) int id);--\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where id = #{id} \u0026lt;/select\u0026gt;   查询一个List集合 1 2 3 4 5  /** * 查询所有用户信息 * @return */ List\u0026lt;User\u0026gt; getUserList();   1 2 3 4  \u0026lt;!--List\u0026lt;User\u0026gt; getUserList();--\u0026gt; \u0026lt;select id=\u0026#34;getUserList\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user \u0026lt;/select\u0026gt;   查询单个数据 1 2 3 4 5 6 7 8 9  /** * 查询用户的总记录数 * @return * 在MyBatis中，对于Java中常用的类型都设置了类型别名 * 例如：java.lang.Integer--\u0026gt;int|integer * 例如：int--\u0026gt;_int|_integer * 例如：Map--\u0026gt;map,List--\u0026gt;list */ int getCount();   1 2 3 4  \u0026lt;!--int getCount();--\u0026gt; \u0026lt;select id=\u0026#34;getCount\u0026#34; resultType=\u0026#34;_integer\u0026#34;\u0026gt; select count(id) from t_user \u0026lt;/select\u0026gt;   查询一条数据为map集合 1 2 3 4 5 6  /** * 根据用户id查询用户信息为map集合 * @param id * @return */ Map\u0026lt;String, Object\u0026gt; getUserToMap(@Param(\u0026#34;id\u0026#34;) int id);   1 2 3 4 5  \u0026lt;!--Map\u0026lt;String, Object\u0026gt; getUserToMap(@Param(\u0026#34;id\u0026#34;) int id);--\u0026gt; \u0026lt;select id=\u0026#34;getUserToMap\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; select * from t_user where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;!--结果：{password=123456, sex=男, id=1, age=23, username=admin}--\u0026gt;   查询多条数据为map集合 方法一 1 2 3 4 5 6  /** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取 */ List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; getAllUserToMap();   1 2 3 4 5 6 7 8 9 10  \u0026lt;!--Map\u0026lt;String, Object\u0026gt; getAllUserToMap();--\u0026gt; \u0026lt;select id=\u0026#34;getAllUserToMap\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; select * from t_user \u0026lt;/select\u0026gt; \u0026lt;!-- 结果： [{password=123456, sex=男, id=1, age=23, username=admin}, {password=123456, sex=男, id=2, age=23, username=张三}, {password=123456, sex=男, id=3, age=23, username=张三}] --\u0026gt;   方法二 1 2 3 4 5 6 7  /** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合 */ @MapKey(\u0026#34;id\u0026#34;) Map\u0026lt;String, Object\u0026gt; getAllUserToMap();   1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!--Map\u0026lt;String, Object\u0026gt; getAllUserToMap();--\u0026gt; \u0026lt;select id=\u0026#34;getAllUserToMap\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; select * from t_user \u0026lt;/select\u0026gt; \u0026lt;!-- 结果： { 1={password=123456, sex=男, id=1, age=23, username=admin}, 2={password=123456, sex=男, id=2, age=23, username=张三}, 3={password=123456, sex=男, id=3, age=23, username=张三} } --\u0026gt;   特殊SQL的执行 模糊查询 1 2 3 4 5 6 7  /** * 根据用户名进行模糊查询 * @param username * @return java.util.List\u0026lt;com.atguigu.mybatis.pojo.User\u0026gt; * @date 2022/2/26 21:56 */ List\u0026lt;User\u0026gt; getUserByLike(@Param(\u0026#34;username\u0026#34;) String username);   1 2 3 4 5 6  \u0026lt;!--List\u0026lt;User\u0026gt; getUserByLike(@Param(\u0026#34;username\u0026#34;) String username);--\u0026gt; \u0026lt;select id=\u0026#34;getUserByLike\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!--select * from t_user where username like \u0026#39;%${mohu}%\u0026#39;--\u0026gt; \u0026lt;!--select * from t_user where username like concat(\u0026#39;%\u0026#39;,#{mohu},\u0026#39;%\u0026#39;)--\u0026gt; select * from t_user where username like \u0026#34;%\u0026#34;#{mohu}\u0026#34;%\u0026#34; \u0026lt;/select\u0026gt;    其中select * from t_user where username like \u0026quot;%\u0026quot;#{mohu}\u0026quot;%\u0026quot;是最常用的  批量删除  只能使用${}，如果使用#{}，则解析后的sql语句为delete from t_user where id in ('1,2,3')，这样是将1,2,3看做是一个整体，只有id为1,2,3的数据会被删除。正确的语句应该是delete from t_user where id in (1,2,3)，或者delete from t_user where id in ('1','2','3')  1 2 3 4 5 6 7  /** * 根据id批量删除 * @param ids * @return int * @date 2022/2/26 22:06 */ int deleteMore(@Param(\u0026#34;ids\u0026#34;) String ids);   1 2 3  \u0026lt;delete id=\u0026#34;deleteMore\u0026#34;\u0026gt; delete from t_user where id in (${ids}) \u0026lt;/delete\u0026gt;   1 2 3 4 5 6 7 8  //测试类 @Test public void deleteMore() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); int result = mapper.deleteMore(\u0026#34;1,2,3,8\u0026#34;); System.out.println(result); }   动态设置表名  只能使用${}，因为表名不能加单引号  1 2 3 4 5 6 7  /** * 查询指定表中的数据 * @param tableName * @return java.util.List\u0026lt;com.atguigu.mybatis.pojo.User\u0026gt; * @date 2022/2/27 14:41 */ List\u0026lt;User\u0026gt; getUserByTable(@Param(\u0026#34;tableName\u0026#34;) String tableName);   1 2 3 4  \u0026lt;!--List\u0026lt;User\u0026gt; getUserByTable(@Param(\u0026#34;tableName\u0026#34;) String tableName);--\u0026gt; \u0026lt;select id=\u0026#34;getUserByTable\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from ${tableName} \u0026lt;/select\u0026gt;   添加功能获取自增的主键   使用场景\n  t_clazz(clazz_id,clazz_name)\n t_student(student_id,student_name,clazz_id)   添加班级信息 获取新添加的班级的id 为班级分配学生，即将某学的班级id修改为新添加的班级的id    在mapper.xml中设置两个属性\n  useGeneratedKeys：设置使用自增的主键\n keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中    1 2 3 4 5 6  /** * 添加用户信息 * @param user * @date 2022/2/27 15:04 */ void insertUser(User user);   1 2 3 4  \u0026lt;!--void insertUser(User user);--\u0026gt; \u0026lt;insert id=\u0026#34;insertUser\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; insert into t_user values (null,#{username},#{password},#{age},#{sex},#{email}) \u0026lt;/insert\u0026gt;   1 2 3 4 5 6 7 8 9 10  //测试类 @Test public void insertUser() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); User user = new User(null, \u0026#34;ton\u0026#34;, \u0026#34;123\u0026#34;, 23, \u0026#34;男\u0026#34;, \u0026#34;123@321.com\u0026#34;); mapper.insertUser(user); System.out.println(user); //输出：user{id=10, username=\u0026#39;ton\u0026#39;, password=\u0026#39;123\u0026#39;, age=23, sex=\u0026#39;男\u0026#39;, email=\u0026#39;123@321.com\u0026#39;}，自增主键存放到了user的id属性中 }   自定义映射resultMap resultMap处理字段和属性的映射关系  resultMap：设置自定义映射 属性：  id：表示自定义映射的唯一标识，不能重复 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系  result：设置普通字段的映射关系 子标签属性： property：设置映射关系中实体类中的属性名  column：设置映射关系中表中的字段名       若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来  1 2 3 4 5 6 7 8 9 10 11  \u0026lt;resultMap id=\u0026#34;empResultMap\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--List\u0026lt;Emp\u0026gt; getAllEmp();--\u0026gt; \u0026lt;select id=\u0026#34;getAllEmp\u0026#34; resultMap=\u0026#34;empResultMap\u0026#34;\u0026gt; select * from t_emp \u0026lt;/select\u0026gt;     若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系\n 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 1 2 3 4  \u0026lt;!--List\u0026lt;Emp\u0026gt; getAllEmp();--\u0026gt; \u0026lt;select id=\u0026#34;getAllEmp\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select eid,emp_name empName,age,sex,email from t_emp \u0026lt;/select\u0026gt;   `` 可以在MyBatis的核心配置文件中的setting标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。核心配置文件详解        多对一映射处理  查询员工信息以及员工所对应的部门信息\n 1 2 3 4 5 6 7 8 9  public class Emp { private Integer eid; private String empName; private Integer age; private String sex; private String email; private Dept dept; //...构造器、get、set方法等 }   级联方式处理映射关系 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapOne\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Emp getEmpAndDept(@Param(\u0026#34;eid\u0026#34;)Integer eid);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpAndDept\u0026#34; resultMap=\u0026#34;empAndDeptResultMapOne\u0026#34;\u0026gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} \u0026lt;/select\u0026gt;   使用association处理映射关系  association：处理多对一的映射关系 property：需要处理多对的映射关系的属性名 javaType：该属性的类型  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapTwo\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; javaType=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Emp getEmpAndDept(@Param(\u0026#34;eid\u0026#34;)Integer eid);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpAndDept\u0026#34; resultMap=\u0026#34;empAndDeptResultMapTwo\u0026#34;\u0026gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} \u0026lt;/select\u0026gt;   分步查询 1. 查询员工信息  select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名） column：设置分步查询的条件  1 2 3 4 5 6 7 8 9  //EmpMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第一步：查询员工信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:17 */ Emp getEmpAndDeptByStepOne(@Param(\u0026#34;eid\u0026#34;) Integer eid);   1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;resultMap id=\u0026#34;empAndDeptByStepResultMap\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; select=\u0026#34;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Emp getEmpAndDeptByStepOne(@Param(\u0026#34;eid\u0026#34;) Integer eid);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpAndDeptByStepOne\u0026#34; resultMap=\u0026#34;empAndDeptByStepResultMap\u0026#34;\u0026gt; select * from t_emp where eid = #{eid} \u0026lt;/select\u0026gt;   2. 查询部门信息 1 2 3 4 5 6 7 8 9  //DeptMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第二步：通过did查询员工对应的部门信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:23 */ Dept getEmpAndDeptByStepTwo(@Param(\u0026#34;did\u0026#34;) Integer did);   1 2 3 4 5 6 7 8 9  \u0026lt;!--此处的resultMap仅是处理字段和属性的映射关系--\u0026gt; \u0026lt;resultMap id=\u0026#34;EmpAndDeptByStepTwoResultMap\u0026#34; type=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Dept getEmpAndDeptByStepTwo(@Param(\u0026#34;did\u0026#34;) Integer did);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpAndDeptByStepTwo\u0026#34; resultMap=\u0026#34;EmpAndDeptByStepTwoResultMap\u0026#34;\u0026gt; select * from t_dept where did = #{did} \u0026lt;/select\u0026gt;   一对多映射处理 1 2 3 4 5 6  public class Dept { private Integer did; private String deptName; private List\u0026lt;Emp\u0026gt; emps; //...构造器、get、set方法等 }   collection  collection：用来处理一对多的映射关系 ofType：表示该属性对饮的集合中存储的数据的类型  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;resultMap id=\u0026#34;DeptAndEmpResultMap\u0026#34; type=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;collection property=\u0026#34;emps\u0026#34; ofType=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Dept getDeptAndEmp(@Param(\u0026#34;did\u0026#34;) Integer did);--\u0026gt; \u0026lt;select id=\u0026#34;getDeptAndEmp\u0026#34; resultMap=\u0026#34;DeptAndEmpResultMap\u0026#34;\u0026gt; select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did} \u0026lt;/select\u0026gt;   分步查询 1. 查询部门信息 1 2 3 4 5 6 7 8  /** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第一步：查询部门信息 * @param did * @return com.atguigu.mybatis.pojo.Dept * @date 2022/2/27 22:04 */ Dept getDeptAndEmpByStepOne(@Param(\u0026#34;did\u0026#34;) Integer did);   1 2 3 4 5 6 7 8 9 10 11  \u0026lt;resultMap id=\u0026#34;DeptAndEmpByStepOneResultMap\u0026#34; type=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;collection property=\u0026#34;emps\u0026#34; select=\u0026#34;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Dept getDeptAndEmpByStepOne(@Param(\u0026#34;did\u0026#34;) Integer did);--\u0026gt; \u0026lt;select id=\u0026#34;getDeptAndEmpByStepOne\u0026#34; resultMap=\u0026#34;DeptAndEmpByStepOneResultMap\u0026#34;\u0026gt; select * from t_dept where did = #{did} \u0026lt;/select\u0026gt;   2. 根据部门id查询部门中的所有员工 1 2 3 4 5 6 7 8  /** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第二步：根据部门id查询部门中的所有员工 * @param did * @return java.util.List\u0026lt;com.atguigu.mybatis.pojo.Emp\u0026gt; * @date 2022/2/27 22:10 */ List\u0026lt;Emp\u0026gt; getDeptAndEmpByStepTwo(@Param(\u0026#34;did\u0026#34;) Integer did);   1 2 3 4  \u0026lt;!--List\u0026lt;Emp\u0026gt; getDeptAndEmpByStepTwo(@Param(\u0026#34;did\u0026#34;) Integer did);--\u0026gt; \u0026lt;select id=\u0026#34;getDeptAndEmpByStepTwo\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp where did = #{did} \u0026lt;/select\u0026gt;   延迟加载  分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息： lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载   此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=\u0026ldquo;lazy(延迟加载)|eager(立即加载)\u0026rdquo;  1 2 3 4  \u0026lt;settings\u0026gt; \u0026lt;!--开启延迟加载--\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   1 2 3 4 5 6 7  @Test public void getEmpAndDeptByStepOne() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = mapper.getEmpAndDeptByStepOne(1); System.out.println(emp.getEmpName()); }    关闭延迟加载，两条SQL语句都运行了 开启延迟加载，只运行获取emp的SQL语句   1 2 3 4 5 6 7 8 9  @Test public void getEmpAndDeptByStepOne() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = mapper.getEmpAndDeptByStepOne(1); System.out.println(emp.getEmpName()); System.out.println(\u0026#34;----------------\u0026#34;); System.out.println(emp.getDept()); }     开启后，需要用到查询dept的时候才会调用相应的SQL语句  fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType=\u0026ldquo;lazy(延迟加载)|eager(立即加载)\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;resultMap id=\u0026#34;empAndDeptByStepResultMap\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; select=\u0026#34;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo\u0026#34; column=\u0026#34;did\u0026#34; fetchType=\u0026#34;lazy\u0026#34;\u0026gt;\u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt;        动态SQL  Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题  if  if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行 在where后面添加一个恒成立条件1=1 这个恒成立条件并不会影响查询的结果  这个1=1可以用来拼接and语句，例如：当empName为null时 如果不加上恒成立条件，则SQL语句为select * from t_emp where and age = ? and sex = ? and email = ?，此时where会与and连用，SQL语句会报错  如果加上一个恒成立条件，则SQL语句为select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?，此时不报错      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!--List\u0026lt;Emp\u0026gt; getEmpByCondition(Emp emp);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpByCondition\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp where 1=1 \u0026lt;if test=\u0026#34;empName != null and empName !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and emp_name = #{empName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null and age !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and age = #{age} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;sex != null and sex !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and sex = #{sex} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null and email !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and email = #{email} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt;   where  where和if一般结合使用： 若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!--List\u0026lt;Emp\u0026gt; getEmpByCondition(Emp emp);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpByCondition\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;empName != null and empName !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; emp_name = #{empName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null and age !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and age = #{age} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;sex != null and sex !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and sex = #{sex} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null and email !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and email = #{email} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;     注意：where标签不能去掉条件后多余的and/or\n1 2 3 4 5 6 7  \u0026lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--\u0026gt; \u0026lt;if test=\u0026#34;empName != null and empName !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; emp_name = #{empName} and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null and age !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; age = #{age} \u0026lt;/if\u0026gt;        trim  trim用于去掉或添加标签中的内容 常用属性 prefix：在trim标签中的内容的前面添加某些内容  suffix：在trim标签中的内容的后面添加某些内容 prefixOverrides：在trim标签中的内容的前面去掉某些内容 suffixOverrides：在trim标签中的内容的后面去掉某些内容   若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下select * from t_emp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!--List\u0026lt;Emp\u0026gt; getEmpByCondition(Emp emp);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpByCondition\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp \u0026lt;trim prefix=\u0026#34;where\u0026#34; suffixOverrides=\u0026#34;and|or\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;empName != null and empName !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; emp_name = #{empName} and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null and age !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; age = #{age} and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;sex != null and sex !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; sex = #{sex} or \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null and email !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; email = #{email} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt;   1 2 3 4 5 6 7 8  //测试类 @Test public void getEmpByCondition() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); List\u0026lt;Emp\u0026gt; emps= mapper.getEmpByCondition(new Emp(null, \u0026#34;张三\u0026#34;, null, null, null, null)); System.out.println(emps); }   choose、when、otherwise  choose、when、otherwise相当于if...else if..else when至少要有一个，otherwise至多只有一个  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;select id=\u0026#34;getEmpByChoose\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;empName != null and empName != \u0026#39;\u0026#39;\u0026#34;\u0026gt; emp_name = #{empName} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;age != null and age != \u0026#39;\u0026#39;\u0026#34;\u0026gt; age = #{age} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;sex != null and sex != \u0026#39;\u0026#39;\u0026#34;\u0026gt; sex = #{sex} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;email != null and email != \u0026#39;\u0026#39;\u0026#34;\u0026gt; email = #{email} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; did = 1 \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;   1 2 3 4 5 6 7  @Test public void getEmpByChoose() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); List\u0026lt;Emp\u0026gt; emps = mapper.getEmpByChoose(new Emp(null, \u0026#34;张三\u0026#34;, 23, \u0026#34;男\u0026#34;, \u0026#34;123@qq.com\u0026#34;, null)); System.out.println(emps); }    相当于if a else if b else if c else d，只会执行其中一个  foreach   属性：\n  collection：设置要循环的数组或集合\n item：表示集合或数组中的每一个数据 separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如, open：设置foreach标签中的内容的开始符 close：设置foreach标签中的内容的结束符    批量删除\n1 2 3 4 5 6 7  \u0026lt;!--int deleteMoreByArray(Integer[] eids);--\u0026gt; \u0026lt;delete id=\u0026#34;deleteMoreByArray\u0026#34;\u0026gt; delete from t_emp where eid in \u0026lt;foreach collection=\u0026#34;eids\u0026#34; item=\u0026#34;eid\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{eid} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt;   1 2 3 4 5 6 7  `java est blic void deleteMoreByArray() { lSession sqlSession = SqlSessionUtils.getSqlSession(); namicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); t result = mapper.deleteMoreByArray(new Integer[]{6, 7, 8, 9}); stem.out.println(result);   1  ](Resources/foreach测试结果1.png)     批量添加\n1 2 3 4 5 6 7  \u0026lt;!--int insertMoreByList(@Param(\u0026#34;emps\u0026#34;) List\u0026lt;Emp\u0026gt; emps);--\u0026gt; \u0026lt;insert id=\u0026#34;insertMoreByList\u0026#34;\u0026gt; insert into t_emp values \u0026lt;foreach collection=\u0026#34;emps\u0026#34; item=\u0026#34;emp\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; (null,#{emp.empName},#{emp.age},#{emp.sex},#{emp.email},null) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  `java est blic void insertMoreByList() { lSession sqlSession = SqlSessionUtils.getSqlSession(); namicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); p emp1 = new Emp(null,\u0026#34;a\u0026#34;,1,\u0026#34;男\u0026#34;,\u0026#34;123@321.com\u0026#34;,null); p emp2 = new Emp(null,\u0026#34;b\u0026#34;,1,\u0026#34;男\u0026#34;,\u0026#34;123@321.com\u0026#34;,null); p emp3 = new Emp(null,\u0026#34;c\u0026#34;,1,\u0026#34;男\u0026#34;,\u0026#34;123@321.com\u0026#34;,null); st\u0026lt;Emp\u0026gt; emps = Arrays.asList(emp1, emp2, emp3); t result = mapper.insertMoreByList(emps); stem.out.println(result);   1  ](Resources/foreach测试结果2.png)     SQL片段  sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入 声明sql片段：\u0026lt;sql\u0026gt;标签  1  \u0026lt;sql id=\u0026#34;empColumns\u0026#34;\u0026gt;eid,emp_name,age,sex,email\u0026lt;/sql\u0026gt;    引用sql片段：\u0026lt;include\u0026gt;标签  1 2 3 4  \u0026lt;!--List\u0026lt;Emp\u0026gt; getEmpByCondition(Emp emp);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpByCondition\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;empColumns\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; from t_emp \u0026lt;/select\u0026gt;   MyBatis的缓存 MyBatis的一级缓存   一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问\n  使一级缓存失效的四种情况：\n 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存    MyBatis的二级缓存   二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取\n  二级缓存开启的条件\n 在核心配置文件中，设置全局配置属性cacheEnabled=\u0026ldquo;true\u0026rdquo;，默认为true，不需要设置 在映射文件中设置标签 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口    使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效\n  二级缓存的相关配置  在mapper配置文件中添加的cache标签可以设置一些属性 eviction属性：缓存回收策略 LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。  FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU   flushInterval属性：刷新间隔，单位毫秒 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新 size属性：引用数目，正整数 代表缓存最多可以存储多少个对象，太大容易导致内存溢出 readOnly属性：只读，true/false true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。  false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false    MyBatis缓存查询的顺序  先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 SqlSession关闭之后，一级缓存中的数据会写入二级缓存  整合第三方缓存EHCache（了解） 添加依赖 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!-- Mybatis EHCache整合包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.caches\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-ehcache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- slf4j日志门面的一个具体实现 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   各个jar包的功能    jar包名称 作用     mybatis-ehcache Mybatis和EHCache的整合包   ehcache EHCache核心包   slf4j-api SLF4J日志门面包   logback-classic 支持SLF4J门面接口的一个具体实现    创建EHCache的配置文件ehcache.xml  名字必须叫ehcache.xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;ehcache xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:noNamespaceSchemaLocation=\u0026#34;../config/ehcache.xsd\u0026#34;\u0026gt; \u0026lt;!-- 磁盘保存路径 --\u0026gt; \u0026lt;diskStore path=\u0026#34;D:\\atguigu\\ehcache\u0026#34;/\u0026gt; \u0026lt;defaultCache maxElementsInMemory=\u0026#34;1000\u0026#34; maxElementsOnDisk=\u0026#34;10000000\u0026#34; eternal=\u0026#34;false\u0026#34; overflowToDisk=\u0026#34;true\u0026#34; timeToIdleSeconds=\u0026#34;120\u0026#34; timeToLiveSeconds=\u0026#34;120\u0026#34; diskExpiryThreadIntervalSeconds=\u0026#34;120\u0026#34; memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;\u0026gt; \u0026lt;/defaultCache\u0026gt; \u0026lt;/ehcache\u0026gt;   设置二级缓存的类型  在xxxMapper.xml文件中设置二级缓存类型  1  \u0026lt;cache type=\u0026#34;org.mybatis.caches.ehcache.EhcacheCache\u0026#34;/\u0026gt;   加入logback日志  存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件logback.xml，名字固定，不可改变  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration debug=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- 指定日志输出的位置 --\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;!-- 日志输出的格式 --\u0026gt; \u0026lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --\u0026gt; \u0026lt;pattern\u0026gt;[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --\u0026gt; \u0026lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --\u0026gt; \u0026lt;root level=\u0026#34;DEBUG\u0026#34;\u0026gt; \u0026lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;!-- 根据特殊需求指定局部日志级别 --\u0026gt; \u0026lt;logger name=\u0026#34;com.atguigu.crowd.mapper\u0026#34; level=\u0026#34;DEBUG\u0026#34;/\u0026gt; \u0026lt;/configuration\u0026gt;   EHCache配置文件说明    属性名 是否必须 作用     maxElementsInMemory 是 在内存中缓存的element的最大数目   maxElementsOnDisk 是 在磁盘上缓存的element的最大数目，若是0表示无穷大   eternal 是 设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断   overflowToDisk 是 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上   timeToIdleSeconds 否 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大   timeToLiveSeconds 否 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大   diskSpoolBufferSizeMB 否 DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区   diskPersistent 否 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false   diskExpiryThreadIntervalSeconds 否 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作   memoryStoreEvictionPolicy 否 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出    MyBatis的逆向工程  正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源： Java实体类  Mapper接口 Mapper映射文件    创建逆向工程的步骤 添加依赖和插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  \u0026lt;dependencies\u0026gt; \u0026lt;!-- MyBatis核心依赖包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit测试 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySQL驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.27\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- log4j日志 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 控制Maven在构建过程中相关配置 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!-- 构建过程中用到的插件 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.0\u0026lt;/version\u0026gt; \u0026lt;!-- 插件的依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- 逆向工程的核心依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据库连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySQL驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.27\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;   创建MyBatis的核心配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;properties resource=\u0026#34;jdbc.properties\u0026#34;/\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   创建逆向工程的配置文件  文件名必须是：generatorConfig.xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026#34;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026#34;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD（清新简洁版） MyBatis3: 生成带条件的CRUD（奢华尊享版） --\u0026gt; \u0026lt;context id=\u0026#34;DB2Tables\u0026#34; targetRuntime=\u0026#34;MyBatis3Simple\u0026#34;\u0026gt; \u0026lt;!-- 数据库的连接信息 --\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34; connectionURL=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34; userId=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/jdbcConnection\u0026gt; \u0026lt;!-- javaBean的生成策略--\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026#34;com.atguigu.mybatis.pojo\u0026#34; targetProject=\u0026#34;.\\src\\main\\java\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;trimStrings\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/javaModelGenerator\u0026gt; \u0026lt;!-- SQL映射文件的生成策略 --\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026#34;com.atguigu.mybatis.mapper\u0026#34; targetProject=\u0026#34;.\\src\\main\\resources\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/sqlMapGenerator\u0026gt; \u0026lt;!-- Mapper接口的生成策略 --\u0026gt; \u0026lt;javaClientGenerator type=\u0026#34;XMLMAPPER\u0026#34; targetPackage=\u0026#34;com.atguigu.mybatis.mapper\u0026#34; targetProject=\u0026#34;.\\src\\main\\java\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/javaClientGenerator\u0026gt; \u0026lt;!-- 逆向分析的表 --\u0026gt; \u0026lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --\u0026gt; \u0026lt;!-- domainObjectName属性指定生成出来的实体类的类名 --\u0026gt; \u0026lt;table tableName=\u0026#34;t_emp\u0026#34; domainObjectName=\u0026#34;Emp\u0026#34;/\u0026gt; \u0026lt;table tableName=\u0026#34;t_dept\u0026#34; domainObjectName=\u0026#34;Dept\u0026#34;/\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt;   执行MBG插件的generate目标   如果出现报错：Exception getting JDBC Driver，可能是pom.xml中，数据库驱动配置错误 dependency中的驱动 mybatis-generator-maven-plugin插件中的驱动 两者的驱动版本应该相同   执行结果  QBC 查询  selectByExample：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据 example.createCriteria().xxx：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系 example.or().xxx：将之前添加的条件通过or拼接其他条件   1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Test public void testMBG() throws IOException { InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); EmpExample example = new EmpExample(); //名字为张三，且年龄大于等于20 \texample.createCriteria().andEmpNameEqualTo(\u0026#34;张三\u0026#34;).andAgeGreaterThanOrEqualTo(20); //或者did不为空 \texample.or().andDidIsNotNull(); List\u0026lt;Emp\u0026gt; emps = mapper.selectByExample(example); emps.forEach(System.out::println); }   增改  updateByPrimaryKey：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null mapper.updateByPrimaryKey(new Emp(1,\u0026quot;admin\u0026quot;,22,null,\u0026quot;456@qq.com\u0026quot;,3));     updateByPrimaryKeySelective()：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段 mapper.updateByPrimaryKeySelective(new Emp(2,\u0026quot;admin2\u0026quot;,22,null,\u0026quot;456@qq.com\u0026quot;,3));      分页插件 分页插件使用步骤 添加依赖 1 2 3 4 5 6  \u0026lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置分页插件  在MyBatis的核心配置文件（mybatis-config.xml）中配置插件   1 2 3 4  \u0026lt;plugins\u0026gt; \u0026lt;!--设置分页插件--\u0026gt; \u0026lt;plugin interceptor=\u0026#34;com.github.pagehelper.PageInterceptor\u0026#34;\u0026gt;\u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt;   分页插件的使用 开启分页功能  在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能 pageNum：当前页的页码  pageSize：每页显示的条数    1 2 3 4 5 6 7 8 9 10 11 12  @Test public void testPageHelper() throws IOException { InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //访问第一页，每页四条数据 \tPageHelper.startPage(1,4); List\u0026lt;Emp\u0026gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println); }   分页相关数据 方法一：直接输出 1 2 3 4 5 6 7 8 9 10 11 12 13  @Test public void testPageHelper() throws IOException { InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //访问第一页，每页四条数据 \tPage\u0026lt;Object\u0026gt; page = PageHelper.startPage(1, 4); List\u0026lt;Emp\u0026gt; emps = mapper.selectByExample(null); //在查询到List集合后，打印分页数据 \tSystem.out.println(page); }     分页相关数据：\n1  Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName=\u0026#39;admin\u0026#39;, age=22, sex=\u0026#39;男\u0026#39;, email=\u0026#39;456@qq.com\u0026#39;, did=3}, Emp{eid=2, empName=\u0026#39;admin2\u0026#39;, age=22, sex=\u0026#39;男\u0026#39;, email=\u0026#39;456@qq.com\u0026#39;, did=3}, Emp{eid=3, empName=\u0026#39;王五\u0026#39;, age=12, sex=\u0026#39;女\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;, did=3}, Emp{eid=4, empName=\u0026#39;赵六\u0026#39;, age=32, sex=\u0026#39;男\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;, did=1}]        方法二使用PageInfo  在查询获取list集合之后，使用PageInfo\u0026lt;T\u0026gt; pageInfo = new PageInfo\u0026lt;\u0026gt;(List\u0026lt;T\u0026gt; list, intnavigatePages)获取分页相关数据 list：分页之后的数据  navigatePages：导航分页的页码数    1 2 3 4 5 6 7 8 9 10 11 12  @Test public void testPageHelper() throws IOException { InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); PageHelper.startPage(1, 4); List\u0026lt;Emp\u0026gt; emps = mapper.selectByExample(null); PageInfo\u0026lt;Emp\u0026gt; page = new PageInfo\u0026lt;\u0026gt;(emps,5); System.out.println(page); }     分页相关数据：\n1 2 3 4  PageInfo{ pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, list=Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName=\u0026#39;admin\u0026#39;, age=22, sex=\u0026#39;男\u0026#39;, email=\u0026#39;456@qq.com\u0026#39;, did=3}, Emp{eid=2, empName=\u0026#39;admin2\u0026#39;, age=22, sex=\u0026#39;男\u0026#39;, email=\u0026#39;456@qq.com\u0026#39;, did=3}, Emp{eid=3, empName=\u0026#39;王五\u0026#39;, age=12, sex=\u0026#39;女\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;, did=3}, Emp{eid=4, empName=\u0026#39;赵六\u0026#39;, age=32, sex=\u0026#39;男\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;, did=1}], prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]}        其中list中的数据等同于方法一中直接输出的page数据\n  常用数据：  pageNum：当前页的页码 pageSize：每页显示的条数 size：当前页显示的真实条数 total：总记录数 pages：总页数 prePage：上一页的页码 nextPage：下一页的页码 isFirstPage/isLastPage：是否为第一页/最后一页 hasPreviousPage/hasNextPage：是否存在上一页/下一页 navigatePages：导航分页的页码数 navigatepageNums：导航分页的页码，[1,2,3,4,5]  ","date":"2022-03-14T17:32:29+08:00","image":"https://vigorwei.github.io/p/mybatis/wallhaven-279676_hude352cef37aba5d2c00ac1368a1ddcc4_60382_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/mybatis/","title":"Mybatis"},{"content":"堆排序 堆排序基本介绍\n1)堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。\n2)堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。\n3)每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆\n大顶堆举例说明\n小顶堆举例说明\n一般升序采用大顶堆，降序采用小顶堆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  public class StackSortDemo { public static void main(String[] args) { int[] arr = {4,6,8,5,9,0,3}; stacksort(arr); System.out.println(Arrays.toString(arr)); } public static void stacksort(int[] arr){ for (int i = arr.length/2 -1; i \u0026gt;=0; i--) { heap(arr,i,arr.length); } for (int i = arr.length-1; i \u0026gt;=0; i--) { int tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; heap(arr,0,i); } } public static void heap(int[] arr,int i,int length){ int tmp = arr[i]; for (int j = 2*i+1; j \u0026lt; length; j = 2*j+1) { if(j+1\u0026lt;length\u0026amp;\u0026amp;arr[j]\u0026lt;arr[j+1]){ j++; } if(arr[j]\u0026gt;tmp){ arr[i] = arr[j]; i = j; }else { break; } } arr[i] = tmp; } }   ","date":"2022-03-13T17:14:49+08:00","image":"https://vigorwei.github.io/p/%E5%A0%86%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%A0%86%E6%8E%92%E5%BA%8F/","title":"堆排序"},{"content":"基数排序 基数排序基本思想\n1)将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n2)这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤\n图解 将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序。\n   ","date":"2022-03-13T17:08:22+08:00","image":"https://vigorwei.github.io/p/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","title":"基数排序"},{"content":"归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治**(conquer)的阶段则将分的阶段得到的各答案\u0026quot;修补\u0026quot;在一起，即分而治之)****。**\n图解 我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  public class MergeSortDemo { public static void main(String[] args) { int[] arr = {8,4,5,7,1,3,6,2,0,234}; int[] nums = new int[arr.length]; mergeRecur(arr,0,arr.length-1,nums); System.out.println(Arrays.toString(arr)); } public static void mergeRecur(int[] arr,int left, int right,int[] nums){ if(left\u0026lt;right){ //System.out.println(\u0026#34;##########\u0026#34;); int mid = (left+right)/2; mergeRecur(arr,left,mid,nums); mergeRecur(arr,mid+1,right,nums); mergeSort(arr,left,mid,right,nums); } } public static void mergeSort(int[] arr,int left,int mid, int right,int[] nums){ int i = left; int j = mid+1; int t = 0; while(i\u0026lt;=mid\u0026amp;\u0026amp;j\u0026lt;=right){ if(arr[i]\u0026lt;=arr[j]){ nums[t] = arr[i]; t+=1; i+=1; }else { nums[t] = arr[j]; t+=1; j+=1; } } while(i\u0026lt;=mid){ nums[t] = arr[i]; t+=1; i+=1; } while(j\u0026lt;=right){ nums[t] = arr[j]; t+=1; j+=1; } int templeft = left; int tempindex = 0; System.out.println(Arrays.toString(nums)); while (templeft\u0026lt;=right){ arr[templeft] = nums[tempindex]; templeft++; tempindex++; }   ","date":"2022-03-13T17:02:27+08:00","image":"https://vigorwei.github.io/p/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","title":"归并排序"},{"content":"快速排序 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class QuickSortDemo { public static void main(String[] args) { int[] arr = {3,4,6,7,2,7,2,8,0,9,1}; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); } public static void quickSort(int[] arr,int start, int end){ if(start\u0026lt;end){ int left = start; int right = end; int pivot = arr[start]; while(left\u0026lt;right){ while(left\u0026lt;right\u0026amp;\u0026amp;arr[right]\u0026gt;=pivot){ right--; } arr[left] = arr[right]; while (left\u0026lt;right\u0026amp;\u0026amp;arr[left]\u0026lt;=pivot){ left++; } arr[right] = arr[left]; } arr[left] = pivot; quickSort(arr,start,left); quickSort(arr,left+1,end); } } }   ","date":"2022-03-13T16:58:49+08:00","image":"https://vigorwei.github.io/p/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","title":"快速排序"},{"content":"希尔排序 简单插入排序存在的问题\n我们看简单的插入排序可能存在的问题.\n数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：\n{2,3,4,5,6,6}\n{2,3,4,5,5,6}\n{2,3,4,4,5,6}\n{2,3,3,4,5,6}\n{2,2,3,4,5,6}\n{1,2,3,4,5,6}\n结论**:** 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.\n希尔排序法介绍\n希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。\n希尔排序法基本思想\n希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止\n图解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public class ShellSortDemo { public static void main(String[] args) { int[] arr = {8,9,1,7,2,3,5,4,6,0}; shellSort3(arr); //shellSort2(arr); } public static void shellSort3(int[] arr){ for (int gap = arr.length/2; gap \u0026gt;0 ; gap = gap/2) { for (int i = gap; i \u0026lt; arr.length; i+=gap) { //for (int j = i-gap; j \u0026gt;0 ; j--) { int insertValue = arr[i]; int index = i-gap; if(arr[index+gap]\u0026lt;arr[index]) { while (index \u0026gt;= 0 \u0026amp;\u0026amp; arr[index] \u0026gt; insertValue) { arr[index + gap] = arr[index]; index = index - gap; } arr[index + gap] = insertValue; // arr[i] = min; } } } System.out.println(Arrays.toString(arr)); } public static void shellSort(int[] arr){ for(int gap = arr.length/2;gap\u0026gt;0;gap = gap/2) { for (int i = gap; i \u0026lt;arr.length; i += gap) { for (int j = i-gap; j \u0026gt;= 0; j --) { if (arr[j] \u0026gt; arr[j + gap]) { int temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; } } } } System.out.println(Arrays.toString(arr)); }   ","date":"2022-03-13T16:54:12+08:00","image":"https://vigorwei.github.io/p/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/","title":"希尔排序"},{"content":"插入排序 插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。\n图解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class InsertSortDemo { public static void main(String[] args) { int[] arr = new int[]{101,34,29,1,7}; // int[] arr = new int[80000]; // for (int i = 0; i \u0026lt; 80000; i++) { // arr[i] = (int) (Math.random()*80000); // } Date date1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); String s1 = simpleDateFormat.format(date1); System.out.println(\u0026#34;排序前的时间 \u0026#34;+ s1); insertSort(arr); Date date2 = new Date(); String s2 = simpleDateFormat.format(date2); System.out.println(\u0026#34;排序后 \u0026#34;+ s2); } public static void insertSort(int[] arr){ for (int i = 1; i \u0026lt; arr.length; i++) { int insertValue = arr[i]; int insertIndex = i-1; while(insertIndex\u0026gt;=0\u0026amp;\u0026amp;insertValue\u0026lt;arr[insertIndex]){ arr[insertIndex+1] = arr[insertIndex]; insertIndex--; } arr[insertIndex+1] = insertValue; } System.out.println(Arrays.toString(arr)); } }   ","date":"2022-03-13T16:48:47+08:00","image":"https://vigorwei.github.io/p/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","title":"插入排序"},{"content":"选择排序 选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public class SelectSortDemo { public static void main(String[] args) { // int[] arr = new int[]{101,34,29,1}; int[] arr = new int[80000]; for (int i = 0; i \u0026lt; 80000; i++) { arr[i] = (int) (Math.random()*80000); } Date date1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); String s1 = simpleDateFormat.format(date1); System.out.println(\u0026#34;排序前的时间 \u0026#34;+ s1); selectDemo(arr); Date date2 = new Date(); String s2 = simpleDateFormat.format(date2); System.out.println(\u0026#34;排序后 \u0026#34;+ s2); } public static void selectDemo(int[] arr){ for (int j = 0; j \u0026lt; arr.length-1; j++) { int min = arr[j]; int minIndex = j; for (int i = j+1; i \u0026lt; arr.length; i++) { if(arr[i]\u0026lt;min){ min = arr[i]; minIndex = i; } } arr[minIndex] = arr[j]; arr[j] = min; } // System.out.println(Arrays.toString(arr)); }   ","date":"2022-03-13T16:35:46+08:00","image":"https://vigorwei.github.io/p/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","title":"选择排序"},{"content":"冒泡排序 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。\n图解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class BubbleSortDemo { public static void main(String[] args) { int[] arr = {3,4,6,7,2,7,2,8,0,9,1}; bubbleSort(arr); System.out.println(Arrays.toString(arr)); } public static void bubbleSort(int[] arr){ for (int i = 0; i \u0026lt; arr.length-1; i++) { for (int j = i+1; j \u0026lt; arr.length; j++) { if(arr[i]\u0026gt;arr[j]){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } } }   ","date":"2022-03-13T16:28:52+08:00","image":"https://vigorwei.github.io/p/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","title":"冒泡排序"},{"content":"hugo更新指令 往基于github的Hugo静态博客推送新博文的步骤分为以下几步：\n 用hugo new命令新建md文件 用hugo -D 生成public html 文件 前往public目录 用git add -A命令将全部更新的文件添加到暂存区 用git commit 命令将暂存区内容添加到分支 用git push 命令将分支内容推到github上去  hugo常用指令集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  git clone https://github.com/digitalcraftsman/hugo-agency-theme hugo server -t hugo-theme-diaspora-master --buildDrafts hugo new post/blog.md hugo --theme=diaspora --baseUrl=\u0026#34;https://vigorwei.github.io/\u0026#34; --buildDrafts cd public git init git add * git commit -m \u0026#34;我的 hugo 博客第一次提交\u0026#34; git remote add origin https://github.com/LastKnightCoder/lastknightcoder.github.io.git git push -u origin master   开始使用hugo！ 下载安装hugo 我们为了简便快速当然选择hugo的二进制安装方式，源码安装有机会再去学习。 去hugo的官方github仓库下载对应的操作系统版本的Hugo二进制文件: 博主以windows64位操作系统为例，下载对应的Windows-64bit.zip。 下载完成后解压缩得到如上文件。\nMac下直接使用Homebrew安装：(其他步骤同理略)\n1  brew install hugo   hugo环境变量配置 上一步操作，可以看到我们把hugo.exe解压到了D:\\hugo下面。所以hugo命令只能在该目录下才能识别。但是我们想要把博客目录建到其他目录下，这就需要配置环境变量。 此电脑-\u0026gt;右键-\u0026gt;点击属性： 再点击高级系统设置： 点击环境变量 在系统变量中找到path，再点击编辑 点击新建，填入hugo解压的文件目录，比如博主解压在D:\\hugo就填的是D:\\hugo 注意：win10以下系统界面不一样，比如win7，直接在path最前或最后加入地址就行，注意用英文;分号分割开，不会的小白可以问度娘。 配置好后点击确定，然后打开cmd命令行程序就可以在任意位置使用hugo命令了。\nhugo新建博客 win+R键打开运行框，输入cmd打开命令行。 使用如下命令\n1  hugo new site /path/to/site   比如hugo new site E:/hugo/hojunBlog就在E盘hugo文件夹下新建了一个叫hojunBlog的hugo站点。 hugo新建页面和文章 新建一个links页面：\n1  hugo new links.md   links.md 自动生成到了 content/links.md，内容如下\n1 2 3 4 5  ---title:\u0026#34;Links\u0026#34;date:2019-04-11T23:35:53+08:00draft:true---  创建第一篇文章，放到 post 目录，方便之后生成聚合页面。\n1  hugo new post/myfirst.md   links.md 自动生成到了 content/post/myfirst.md，内容如下:(注意这里需要把draft删除掉，不然正式生产的时候不会生成文章，因为draft是草稿)\n1 2 3 4 5  ---title:\u0026#34;Myfirst\u0026#34;date:2019-04-13T23:23:34+08:00draft:true---  hugo安装主题 新建文章后不要着急，还需要安装hugo主题才行。去官方主题列表themes.gohugo.io里去挑选自己想要的主题。 。 我们这里以icarus主题为例来安装主题。github仓库地址github.com/digitalcraftsman/hugo-icarus-theme 根据文档clone主题 在Hugo站点运行的文件夹中\n1 2  cd themes git clone https://github.com/digitalcraftsman/hugo-icarus-theme.git   配置主题 找到icarus主题下的hojunBlog\\themes\\hugo-icarus-theme\\exampleSite\\config.toml复制其内容到根目录下的hojunBlog\\config.toml中，接着修改根目录下的配置文件部分内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  baseurl = \u0026#34;https://yourname.github.io\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;Icarus\u0026#34; # Enable comments by entering your Disqus shortname disqusShortname = \u0026#34;spf13\u0026#34; # Enable Google Analytics by entering your tracking code googleAnalytics = \u0026#34;\u0026#34; # Define the number of posts per page paginate = 10 footnotereturnlinkcontents = \u0026#34;↩\u0026#34; theme = \u0026#34;hugo-icarus-theme\u0026#34; # Comment the themesDir option if you use this theme in production themesDir = \u0026#34;./themes/\u0026#34;   其中重要的是baseurl、theme、themesDir的配置，其他的配置可以之后慢慢设置。baseurl需要改成你的github pages的仓库名，theme、themesDir改成主题目录名和主题路径（上图填的是相对路径）。 其他配置可以参考icarus主题的文档，这里就不做介绍了。\n使用命令来预览、发布主题 在根目录（比如这里是hojunBlog下）执行：\n1  hugo server   然后打开浏览器，输入localhost:1313就可以看到自己的博客了！（注意之前说的文章里的draft: true要删掉哦） 接着就是要发布主题到github上了，注册github，新建yourname.github.io的仓库，配置SSH，复制仓库的github pages地址到之前说的配置的baseurl中(就是https://yourname.github.io)，然后使用命令：\n","date":"2022-03-13T15:05:12+08:00","image":"https://vigorwei.github.io/p/hugo-relate-api/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/hugo-relate-api/","title":"Hugo Relate Api"}]
[{"content":"Spring-AOP 1、AOP 基本概念 （1）面向切面编程（方面），利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得 业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。\n（2）通俗描述：不通过修改源代码方式，在主干功能里面添加新功能\n（3）使用登录例子说明 AOP\n2、AOP（底层原理） a）AOP 底层使用动态代理 ，动态代理有两种情况：\n第一种 有接口情况，使用 JDK 动态代理 ；创建接口实现类代理对象，增强类的方法\n第二种 没有接口情况，使用 CGLIB 动态代理；创建子类的代理对象，增强类的方法\n3、AOP（JDK 动态代理） 1）使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象\n1 2 3 4 5 6 7 8  public static Object newProxyInstance(ClassLoader loader, Class\u0026lt;?\u0026gt;[] interfaces, InvocationHandler h) ​ 第一参数，类加载器 ​ 第二参数，增强方法所在的类，这个类实现的接口，支持多个接口 ​ 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分   2）编写 JDK 动态代理代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  //（1）创建接口，定义方法 public interface UserDao { public int add(int a,int b); public String update(String id); } //（2）创建接口实现类，实现方法 public class UserDaoImpl implements UserDao { @Override public int add(int a, int b) { return a+b; } @Override public String update(String id) { return id; } } //（3）使用 Proxy 类创建接口代理对象 public class JDKProxy { public static void main(String[] args) { //创建接口实现类代理对象 Class[] interfaces = {UserDao.class}; UserDaoImpl userDao = new UserDaoImpl(); /** 第一参数，类加载器 第二参数，增强方法所在的类，这个类实现的接口，(支持多个接口) 第三参数，实现这个接口 InvocationHandler，创建代理对象，写增强的部分 */ UserDao dao =(UserDao)Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao)); int result = dao.add(1, 2); System.out.println(\u0026#34;result:\u0026#34;+result); } } //创建代理对象代码 class UserDaoProxy implements InvocationHandler { //1 把创建的是谁的代理对象，把谁传递过来 //有参数构造传递 private Object obj; public UserDaoProxy(Object obj) { this.obj = obj; } //增强的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //方法之前 System.out.println(\u0026#34;方法之前执行....\u0026#34;+method.getName()+\u0026#34; :传递的参数...\u0026#34;+ Arrays.toString(args)); //被增强的方法执行 Object res = method.invoke(obj, args); //方法之后 System.out.println(\u0026#34;方法之后执行....\u0026#34;+obj); return res; } }   4、AOP（术语） a）连接点：类里面哪些方法可以被增强，这些方法称为连接点\nb）切入点：实际被真正增强的方法称为切入点\nc）通知（增强）：实际增强的逻辑部分称为通知，且分为以下五种类型：\n1）前置通知 2）后置通知 3）环绕通知 4）异常通知 5）最终通知\nd）切面：把通知应用到切入点过程\n5、AOP操作 a）Spring 框架一般都是基于 AspectJ 实现 AOP 操作，AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使 用，进行 AOP 操作\nb）基于 AspectJ 实现 AOP 操作：1）基于 xml 配置文件实现 （2）基于注解方式实现（使用）\nc）引入相关jar包\nd）切入点表达式，如下\n1 2 3 4 5 6 7 8 9  （1）切入点表达式作用：知道对哪个类里面的哪个方法进行增强 （2）语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表]) ) （3）例子如下： 例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 execution(* com.atguigu.dao.BookDao.add(..)) 例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 execution(* com.atguigu.dao.BookDao.* (..)) 例 3：对 com.atguigu.dao 包里面所有类，类里面所有方法进行增强 execution(* com.atguigu.dao.*.* (..))   6、AOP 操作（AspectJ 注解） 1 2 3 4 5 6 7 8 9 10 11 12 13 14  //1、创建类，在类里面定义方法 public class User { public void add() { System.out.println(\u0026#34;add.......\u0026#34;); } } //2、创建增强类（编写增强逻辑） //（1）在增强类里面，创建方法，让不同方法代表不同通知类型 //增强的类 public class UserProxy { public void before() {//前置通知 System.out.println(\u0026#34;before......\u0026#34;); } }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!--3、进行通知的配置--\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:aop=\u0026#34;http://www.springframework.org/schema/aop\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\u0026#34;\u0026gt; \u0026lt;!-- 开启注解扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu.spring5.aopanno\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt; \u0026lt;!-- 开启Aspect生成代理对象--\u0026gt; \u0026lt;aop:aspectj-autoproxy\u0026gt;\u0026lt;/aop:aspectj-autoproxy\u0026gt; \u0026lt;/beans\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  //增强的类 @Component @Aspect //生成代理对象 public class UserProxy {} //被增强的类 @Component public class User {} //4、配置不同类型的通知 @Component @Aspect //生成代理对象 public class UserProxy { //相同切入点抽取 @Pointcut(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void pointdemo() { } //前置通知 //@Before注解表示作为前置通知 @Before(value = \u0026#34;pointdemo()\u0026#34;)//相同切入点抽取使用！ public void before() { System.out.println(\u0026#34;before.........\u0026#34;); } //后置通知（返回通知） @AfterReturning(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void afterReturning() { System.out.println(\u0026#34;afterReturning.........\u0026#34;); } //最终通知 @After(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void after() { System.out.println(\u0026#34;after.........\u0026#34;); } //异常通知 @AfterThrowing(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void afterThrowing() { System.out.println(\u0026#34;afterThrowing.........\u0026#34;); } //环绕通知 @Around(value = \u0026#34;execution(* com.atguigu.spring5.aopanno.User.add(..))\u0026#34;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(\u0026#34;环绕之前.........\u0026#34;); //被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(\u0026#34;环绕之后.........\u0026#34;); } }   7、有多个增强类对同一个方法进行增强，设置增强类优先级 1 2 3 4 5  //（1）在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 @Component @Aspect @Order(1) public class PersonProxy{ }   8、AOP 操作（AspectJ 配置文件） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!--1、创建两个类，增强类和被增强类，创建方法（同上一样）--\u0026gt; \u0026lt;!--2、在 spring 配置文件中创建两个类对象--\u0026gt; \u0026lt;!--创建对象--\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.aopxml.Book\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;bookProxy\u0026#34; class=\u0026#34;com.atguigu.spring5.aopxml.BookProxy\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; \u0026lt;!--3、在 spring 配置文件中配置切入点--\u0026gt; \u0026lt;!--配置 aop 增强--\u0026gt; \u0026lt;aop:config\u0026gt; \u0026lt;!--切入点--\u0026gt; \u0026lt;aop:pointcut id=\u0026#34;p\u0026#34; expression=\u0026#34;execution(* com.atguigu.spring5.aopxml.Book.buy(..))\u0026#34;/\u0026gt; \u0026lt;!--配置切面--\u0026gt; \u0026lt;aop:aspect ref=\u0026#34;bookProxy\u0026#34;\u0026gt; \u0026lt;!--增强作用在具体的方法上--\u0026gt; \u0026lt;aop:before method=\u0026#34;before\u0026#34; pointcut-ref=\u0026#34;p\u0026#34;/\u0026gt; \u0026lt;/aop:aspect\u0026gt; \u0026lt;/aop:config\u0026gt;   ","date":"2022-03-16T15:47:13+08:00","image":"https://vigorwei.github.io/p/sping5-aop/cover-v1.2.0_hu27a756884c7e9dfb9cbdf758af038fda_343566_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/sping5-aop/","title":"Sping5 Aop"},{"content":"IOC 操作 Bean 管理(基于注解方式) 1、什么是注解 （1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值…)\n（2）使用注解，注解作用在类上面，方法上面，属性上面\n（3）使用注解目的：简化 xml 配置\n2、Spring 针对 Bean 管理中创建对象提供注解 下面四个注解功能是一样的，都可以用来创建 bean 实例\n（1）@Component\n（2）@Service\n（3）@Controller\n（4）@Repository\n3、基于注解方式实现对象创建 第一步 引入依赖 （引入spring-aop jar包）\n第二步 开启组件扫描\n1 2 3 4 5  \u0026lt;!--开启组件扫描 1 如果扫描多个包，多个包使用逗号隔开 2 扫描包上层目录 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu\u0026#34;\u0026gt;\u0026lt;/context:component-scan\u0026gt;   第三步 创建类，在类上面添加创建对象注解\n1 2 3 4 5 6 7 8 9  //在注解里面 value 属性值可以省略不写， //默认值是类名称，首字母小写 //UserService -- userService @Component(value = \u0026#34;userService\u0026#34;) //注解等同于XML配置文件：\u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;..\u0026#34;/\u0026gt; public class UserService { public void add() { System.out.println(\u0026#34;service add.......\u0026#34;); } }   4、开启组件扫描细节配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!--示例 1 use-default-filters=\u0026#34;false\u0026#34; 表示现在不使用默认 filter，自己配置 filter context:include-filter ，设置扫描哪些内容 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu\u0026#34; use-defaultfilters=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;context:include-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt;\u0026lt;!--代表只扫描Controller注解的类--\u0026gt; \u0026lt;/context:component-scan\u0026gt; \u0026lt;!--示例 2 下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.atguigu\u0026#34;\u0026gt; \u0026lt;context:exclude-filter type=\u0026#34;annotation\u0026#34; expression=\u0026#34;org.springframework.stereotype.Controller\u0026#34;/\u0026gt;\u0026lt;!--表示Controller注解的类之外一切都进行扫描--\u0026gt; \u0026lt;/context:component-scan\u0026gt;   5、基于注解方式实现属性注入 （1）@Autowired：根据属性类型进行自动装配\n第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解\n第二步 在 service 注入 dao 对象，在 service 类添加 dao 类型属性，在属性上面使用注解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  @Service public class UserService { //定义 dao 类型属性 //不需要添加 set 方法 //添加注入属性注解 @Autowired private UserDao userDao; public void add() { System.out.println(\u0026#34;service add.......\u0026#34;); userDao.add(); } } //Dao实现类 @Repository //@Repository(value = \u0026#34;userDaoImpl1\u0026#34;) public class UserDaoImpl implements UserDao { @Override public void add() { System.out.println(\u0026#34;dao add.....\u0026#34;); } }   （2）@Qualifier：根据名称进行注入，这个@Qualifier 注解的使用，和上面@Autowired 一起使用\n1 2 3 4 5 6 7  //定义 dao 类型属性 //不需要添加 set 方法 //添加注入属性注解 @Autowired //根据类型进行注入 //根据名称进行注入（目的在于区别同一接口下有多个实现类，根据类型就无法选择，从而出错！） @Qualifier(value = \u0026#34;userDaoImpl1\u0026#34;) private UserDao userDao;   （3）@Resource：可以根据类型注入，也可以根据名称注入（它属于javax包下的注解，不推荐使用！）\n1 2 3  //@Resource //根据类型进行注入 @Resource(name = \u0026#34;userDaoImpl1\u0026#34;) //根据名称进行注入 private UserDao userDao;   （4）@Value：注入普通类型属性\n1 2  @Value(value = \u0026#34;abc\u0026#34;) private String name   6、完全注解开发 （1）创建配置类，替代 xml 配置文件\n1 2 3 4 5  @Configuration //作为配置类，替代 xml 配置文件 @ComponentScan(basePackages = {\u0026#34;com.atguigu\u0026#34;}) public class SpringConfig { }   （2）编写测试类\n1 2 3 4 5 6 7 8 9 10  @Test public void testService2() { //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(\u0026#34;userService\u0026#34;, UserService.class); System.out.println(userService); userService.add(); }   ","date":"2022-03-14T20:17:57+08:00","image":"https://vigorwei.github.io/p/spring5-ioc%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/cover-v1.2.0_hu27a756884c7e9dfb9cbdf758af038fda_343566_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/spring5-ioc%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F/","title":"Spring5-IOC注解方式"},{"content":"Spring——IOC（控制反转） 一、IOC容器 1、什么是IOC（控制反转） a）把对象创建和对象之间的调用过程，交给Spring进行管理\nb）使用IOC目的：为了降低耦合度\n2、IOC底层 a）xml解析、工厂模式、反射\n3、Spring提供的IOC容器实现的两种方式（两个接口） a）BeanFactory接口：IOC容器基本实现是Spring内部接口的使用接口，不提供给开发人员进行使用（加载配置文件时候不会创建对象，在获取对象时才会创建对象。）\nb）ApplicationContext接口：BeanFactory接口的子接口，提供更多更强大的功能，提供给开发人员使用（加载配置文件时候就会把在配置文件对象进行创建）推荐使用！\n4、ApplicationContext接口的实现类（具体根据API文档查看☺） 二、IOC容器-Bean管理 1、IOC操作Bean管理 a）Bean管理就是两个操作：（1）Spring创建对象；（2）Spring注入属性\n2、基于XML配置文件创建对象 1 2  \u0026lt;!--1 配置User对象创建--\u0026gt; \u0026lt;bean id=\u0026#34;user\u0026#34; class=\u0026#34;com.atguigu.spring5.User\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;   3、基于XML方式注入属性（DI：依赖注入（注入属性）） a）set方式注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  //（1）传统方式： 创建类，定义属性和对应的set方法 public class Book { //创建属性 private String bname; //创建属性对应的set方法 public void setBname(String bname) { this.bname = bname; } } \u0026lt;!--（2）spring方式： set方法注入属性--\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.Book\u0026#34;\u0026gt; \u0026lt;!--使用property完成属性注入 name：类里面属性名称 value：向属性注入的值 --\u0026gt; \u0026lt;property name=\u0026#34;bname\u0026#34; value=\u0026#34;Hello\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;bauthor\u0026#34; value=\u0026#34;World\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   b）有参构造函数注入\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  //（1）传统方式：创建类，构建有参函数 public class Orders { //属性 private String oname; private String address; //有参数构造 public Orders(String oname,String address) { this.oname = oname; this.address = address; } } \u0026lt;!--（2）spring方式：有参数构造注入属性--\u0026gt; \u0026lt;bean id=\u0026#34;orders\u0026#34; class=\u0026#34;com.atguigu.spring5.Orders\u0026#34;\u0026gt; \u0026lt;constructor-arg name=\u0026#34;oname\u0026#34; value=\u0026#34;Hello\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;constructor-arg name=\u0026#34;address\u0026#34; value=\u0026#34;China！\u0026#34;\u0026gt;\u0026lt;/constructor-arg\u0026gt; \u0026lt;/bean\u0026gt;   c）p名称空间注入（了解即可）\n1 2 3 4 5 6 7 8 9  \u0026lt;!--1、添加p名称空间在配置文件头部--\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:p=\u0026#34;http://www.springframework.org/schema/p\u0026#34;\t\u0026lt;!--在这里添加一行p--\u0026gt; \u0026lt;!--2、在bean标签进行属性注入（算是set方式注入的简化操作）--\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.Book\u0026#34; p:bname=\u0026#34;very\u0026#34; p:bauthor=\u0026#34;good\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt;   4、注入空值和特殊符号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.Book\u0026#34;\u0026gt; \u0026lt;!--（1）null值--\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34;\u0026gt; \u0026lt;null/\u0026gt;\u0026lt;!--属性里边添加一个null标签--\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--（2）特殊符号赋值--\u0026gt; \u0026lt;!--属性值包含特殊符号 a 把\u0026lt;\u0026gt;进行转义 \u0026amp;lt; \u0026amp;gt; b 把带特殊符号内容写到CDATA --\u0026gt; \u0026lt;property name=\u0026#34;address\u0026#34;\u0026gt; \u0026lt;value\u0026gt;\u0026lt;![CDATA[\u0026lt;\u0026lt;南京\u0026gt;\u0026gt;]]\u0026gt;\u0026lt;/value\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   5、注入属性-外部bean a）创建两个类service和dao类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class UserService {//service类 //创建UserDao类型属性，生成set方法 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add() { System.out.println(\u0026#34;service add...............\u0026#34;); userDao.update();//调用dao方法 } } public class UserDaoImpl implements UserDao {//dao类 @Override public void update() { System.out.println(\u0026#34;dao update...........\u0026#34;); } }   b）在spring配置文件中进行配置\n1 2 3 4 5 6 7 8 9  \u0026lt;!--1 service和dao对象创建--\u0026gt; \u0026lt;bean id=\u0026#34;userService\u0026#34; class=\u0026#34;com.atguigu.spring5.service.UserService\u0026#34;\u0026gt; \u0026lt;!--注入userDao对象 name属性：类里面属性名称 ref属性：创建userDao对象bean标签id值 --\u0026gt; \u0026lt;property name=\u0026#34;userDao\u0026#34; ref=\u0026#34;userDaoImpl\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;userDaoImpl\u0026#34; class=\u0026#34;com.atguigu.spring5.dao.UserDaoImpl\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt;   6、基于XML方式注入内部bean和级联赋值 a）注入属性-内部bea\n（1）一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门（部门是一，员工是多） （2）在实体类之间表示一对多关系，员工表示所属部门，使用对象类型属性进行表示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //部门类 public class Dept { private String dname; public void setDname(String dname) { this.dname = dname; } } //员工类 public class Emp { private String ename; private String gender; //员工属于某一个部门，使用对象形式表示 private Dept dept; public void setDept(Dept dept) { this.dept = dept; } public void setEname(String ename) { this.ename = ename; } public void setGender(String gender) { this.gender = gender; } }   （3）在spring配置文件中配置\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!--内部bean--\u0026gt; \u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Emp\u0026#34;\u0026gt; \u0026lt;!--设置两个普通属性--\u0026gt; \u0026lt;property name=\u0026#34;ename\u0026#34; value=\u0026#34;Andy\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--设置对象类型属性--\u0026gt; \u0026lt;property name=\u0026#34;dept\u0026#34;\u0026gt; \u0026lt;bean id=\u0026#34;dept\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Dept\u0026#34;\u0026gt;\u0026lt;!--内部bean赋值--\u0026gt; \u0026lt;property name=\u0026#34;dname\u0026#34; value=\u0026#34;宣传部门\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   b）注入属性-级联赋值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  \u0026lt;!--方式一：级联赋值--\u0026gt; \u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Emp\u0026#34;\u0026gt; \u0026lt;!--设置两个普通属性--\u0026gt; \u0026lt;property name=\u0026#34;ename\u0026#34; value=\u0026#34;Andy\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--级联赋值--\u0026gt; \u0026lt;property name=\u0026#34;dept\u0026#34; ref=\u0026#34;dept\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dept\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Dept\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;dname\u0026#34; value=\u0026#34;公关部门\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; //方式二：生成dept的get方法（get方法必须有！！） public Dept getDept() { return dept; } \u0026lt;!--级联赋值--\u0026gt; \u0026lt;bean id=\u0026#34;emp\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Emp\u0026#34;\u0026gt; \u0026lt;!--设置两个普通属性--\u0026gt; \u0026lt;property name=\u0026#34;ename\u0026#34; value=\u0026#34;jams\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;gender\u0026#34; value=\u0026#34;男\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;!--级联赋值--\u0026gt; \u0026lt;property name=\u0026#34;dept\u0026#34; ref=\u0026#34;dept\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;dept.dname\u0026#34; value=\u0026#34;技术部门\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;dept\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Dept\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt;   7、IOC 操作 Bean 管理——xml 注入集合属性 1、注入数组类型属性 2、注入 List 集合类型属性 3、注入 Map 集合类型属性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  //（1）创建类，定义数组、list、map、set 类型属性，生成对应 set 方法 public class Stu { //1 数组类型属性 private String[] courses; //2 list集合类型属性 private List\u0026lt;String\u0026gt; list; //3 map集合类型属性 private Map\u0026lt;String,String\u0026gt; maps; //4 set集合类型属性 private Set\u0026lt;String\u0026gt; sets; public void setSets(Set\u0026lt;String\u0026gt; sets) { this.sets = sets; } public void setCourses(String[] courses) { this.courses = courses; } public void setList(List\u0026lt;String\u0026gt; list) { this.list = list; } public void setMaps(Map\u0026lt;String, String\u0026gt; maps) { this.maps = maps; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  \u0026lt;!--（2）在 spring 配置文件进行配置--\u0026gt; \u0026lt;bean id=\u0026#34;stu\u0026#34; class=\u0026#34;com.atguigu.spring5.collectiontype.Stu\u0026#34;\u0026gt; \u0026lt;!--数组类型属性注入--\u0026gt; \u0026lt;property name=\u0026#34;courses\u0026#34;\u0026gt; \u0026lt;array\u0026gt; \u0026lt;value\u0026gt;java课程\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;数据库课程\u0026lt;/value\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--list类型属性注入--\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;张三\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;小三\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--map类型属性注入--\u0026gt; \u0026lt;property name=\u0026#34;maps\u0026#34;\u0026gt; \u0026lt;map\u0026gt; \u0026lt;entry key=\u0026#34;JAVA\u0026#34; value=\u0026#34;java\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;entry key=\u0026#34;PHP\u0026#34; value=\u0026#34;php\u0026#34;\u0026gt;\u0026lt;/entry\u0026gt; \u0026lt;/map\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;!--set类型属性注入--\u0026gt; \u0026lt;property name=\u0026#34;sets\u0026#34;\u0026gt; \u0026lt;set\u0026gt; \u0026lt;value\u0026gt;MySQL\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;Redis\u0026lt;/value\u0026gt; \u0026lt;/set\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   8、在集合里面设置对象类型值 1 2 3 4 5  //学生所学多门课程 private List\u0026lt;Course\u0026gt; courseList;//创建集合 public void setCourseList(List\u0026lt;Course\u0026gt; courseList) { this.courseList = courseList; }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!--创建多个course对象--\u0026gt; \u0026lt;bean id=\u0026#34;course1\u0026#34; class=\u0026#34;com.atguigu.spring5.collectiontype.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cname\u0026#34; value=\u0026#34;Spring5框架\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;course2\u0026#34; class=\u0026#34;com.atguigu.spring5.collectiontype.Course\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;cname\u0026#34; value=\u0026#34;MyBatis框架\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--注入list集合类型，值是对象--\u0026gt; \u0026lt;property name=\u0026#34;courseList\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;ref bean=\u0026#34;course1\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;ref bean=\u0026#34;course2\u0026#34;\u0026gt;\u0026lt;/ref\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;!--第一步：在 spring 配置文件中引入名称空间 util--\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:util=\u0026#34;http://www.springframework.org/schema/util\u0026#34; \u0026lt;!--添加util名称空间--\u0026gt; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\u0026#34;\u0026gt; \u0026lt;!--添加util名称空间--\u0026gt; \u0026lt;!--第二步：使用 util 标签完成 list 集合注入提取--\u0026gt; \u0026lt;!--把集合注入部分提取出来--\u0026gt; \u0026lt;!--1 提取list集合类型属性注入--\u0026gt; \u0026lt;util:list id=\u0026#34;bookList\u0026#34;\u0026gt; \u0026lt;value\u0026gt;易筋经\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;九阴真经\u0026lt;/value\u0026gt; \u0026lt;value\u0026gt;九阳神功\u0026lt;/value\u0026gt; \u0026lt;/util:list\u0026gt; \u0026lt;!--2 提取list集合类型属性注入使用--\u0026gt; \u0026lt;bean id=\u0026#34;book\u0026#34; class=\u0026#34;com.atguigu.spring5.collectiontype.Book\u0026#34; scope=\u0026#34;prototype\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;list\u0026#34; ref=\u0026#34;bookList\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   Spring IOC容器-Bean管理——基于XML 1、IOC 操作 Bean 管理（FactoryBean）\n1、Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）\n2、普通 bean：在配置文件中定义 bean 类型就是返回类型\n3、工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class MyBean implements FactoryBean\u0026lt;Course\u0026gt; { //定义返回bean @Override public Course getObject() throws Exception { Course course = new Course(); course.setCname(\u0026#34;abc\u0026#34;); return course; } } \u0026lt;bean id=\u0026#34;myBean\u0026#34; class=\u0026#34;com.atguigu.spring5.factorybean.MyBean\u0026#34;\u0026gt; \u0026lt;/bean\u0026gt; @Test public void test3() { ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean3.xml\u0026#34;); Course course = context.getBean(\u0026#34;myBean\u0026#34;, Course.class);//返回值类型可以不是定义的bean类型！ System.out.println(course); }   2、IOC 操作 Bean 管理（bean 作用域）\n在 Spring 里面，默认情况下，bean 是单实例对象，下面进行作用域设置：\n（1）在 spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例\n（2）scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象\n（3）singleton 和 prototype 区别\na）singleton 单实例，prototype 多实例\nb）设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象 ；设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象\n3、IOC 操作 Bean 管理（bean 生命周期）\n1、生命周期 ：从对象创建到对象销毁的过程\n2、bean 生命周期\n（1）通过构造器创建 bean 实例（无参数构造）\n（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n（3）调用 bean 的初始化的方法（需要进行配置初始化的方法）\n（4）bean 可以使用了（对象获取到了）\n（5）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n3、演示 bean 生命周期 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  public class Orders { //无参数构造 public Orders() { System.out.println(\u0026#34;第一步 执行无参数构造创建 bean 实例\u0026#34;); } private String oname; public void setOname(String oname) { this.oname = oname; System.out.println(\u0026#34;第二步 调用 set 方法设置属性值\u0026#34;); } //创建执行的初始化的方法 public void initMethod() { System.out.println(\u0026#34;第三步 执行初始化的方法\u0026#34;); } //创建执行的销毁的方法 public void destroyMethod() { System.out.println(\u0026#34;第五步 执行销毁的方法\u0026#34;); } } public class MyBeanPost implements BeanPostProcessor {//创建后置处理器实现类 @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;在初始化之前执行的方法\u0026#34;); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\u0026#34;在初始化之后执行的方法\u0026#34;); return bean; } } \u0026lt;!--配置文件的bean参数配置--\u0026gt; \u0026lt;bean id=\u0026#34;orders\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.Orders\u0026#34; init-method=\u0026#34;initMethod\u0026#34; destroy-method=\u0026#34;destroyMethod\u0026#34;\u0026gt;\t\u0026lt;!--配置初始化方法和销毁方法--\u0026gt; \u0026lt;property name=\u0026#34;oname\u0026#34; value=\u0026#34;手机\u0026#34;\u0026gt;\u0026lt;/property\u0026gt;\u0026lt;!--这里就是通过set方式（注入属性）赋值--\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置后置处理器--\u0026gt; \u0026lt;bean id=\u0026#34;myBeanPost\u0026#34; class=\u0026#34;com.atguigu.spring5.bean.MyBeanPost\u0026#34;\u0026gt;\u0026lt;/bean\u0026gt; @Test public void testBean3() { // ApplicationContext context = // new ClassPathXmlApplicationContext(\u0026#34;bean4.xml\u0026#34;); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;bean4.xml\u0026#34;); Orders orders = context.getBean(\u0026#34;orders\u0026#34;, Orders.class); System.out.println(\u0026#34;第四步 获取创建 bean 实例对象\u0026#34;); System.out.println(orders); //手动让 bean 实例销毁 context.close(); }   4、bean 的后置处理器，bean 生命周期有七步 （正常生命周期为五步，而配置后置处理器后为七步）\n（1）通过构造器创建 bean 实例（无参数构造）\n（2）为 bean 的属性设置值和对其他 bean 引用（调用 set 方法）\n（3）把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization\n（4）调用 bean 的初始化的方法（需要进行配置初始化的方法）\n（5）把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization\n（6）bean 可以使用了（对象获取到了）\n（7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法）\n4、IOC 操作 Bean 管理(外部属性文件) 方式一：直接配置数据库信息 ：（1）配置Druid（德鲁伊）连接池 （2）引入Druid（德鲁伊）连接池依赖 jar 包\n1 2 3 4 5 6 7  \u0026lt;!--直接配置连接池--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;com.mysql.jdbc.Driver\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/userDb\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;root\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt;   方式二：引入外部属性文件配置数据库连接池\n（1）创建外部属性文件，properties 格式文件，写数据库信息（jdbc.properties）\n1 2 3 4  prop.driverClass=com.mysql.jdbc.Driver prop.url=jdbc:mysql://localhost:3306/userDb prop.userName=root prop.password=root   （2）把外部 properties 属性文件引入到 spring 配置文件中 —— 引入 context 名称空间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt;\u0026lt;!--引入context名称空间--\u0026gt; \u0026lt;!--引入外部属性文件--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;!--配置连接池--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.alibaba.druid.pool.DruidDataSource\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driverClassName\u0026#34; value=\u0026#34;${prop.driverClass}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${prop.url}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${prop.userName}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${prop.password}\u0026#34;\u0026gt;\u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;/beans\u0026gt;   ","date":"2022-03-14T19:25:09+08:00","image":"https://vigorwei.github.io/p/spring5-ioc-xml%E6%96%B9%E5%BC%8F/cover-v1.2.0_hu27a756884c7e9dfb9cbdf758af038fda_343566_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/spring5-ioc-xml%E6%96%B9%E5%BC%8F/","title":"Spring5-IOC XML方式"},{"content":"Mybatis简介 MyBatis历史  MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下，iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github iBatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）  MyBatis特性  MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架  MyBatis下载  MyBatis下载地址   和其它持久化层技术对比  JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤  维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低   Hibernate 和 JPA 操作简便，开发效率高  程序中的长难复杂 SQL 需要绕过框架 内部自动生产的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。 反射操作太多，导致数据库性能下降   MyBatis 轻量级，性能出色  SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于HIbernate，但是完全能够接受    搭建MyBatis 开发环境  IDE：idea 2019.2 构建工具：maven 3.5.4 MySQL版本：MySQL 5.7 MyBatis版本：MyBatis 3.5.7  创建maven工程   打包方式：jar\n  引入依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;dependencies\u0026gt; \u0026lt;!-- Mybatis核心 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit测试 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.12\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySQL驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;        创建MyBatis的核心配置文件  习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。 核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息 核心配置文件存放的位置是src/main/resources目录下\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--设置连接数据库的环境--\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;jdbc:mysql://localhost:3306/MyBatis\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;root\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;123456\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--引入映射文件--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;mappers/UserMapper.xml\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   创建mapper接口  MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类\n 1 2 3 4 5 6 7 8  package com.atguigu.mybatis.mapper; public interface UserMapper { /** * 添加用户信息 */ int insertUser(); }   创建MyBatis的映射文件  相关概念：ORM（Object Relationship Mapping）对象关系映射。 对象：Java的实体类对象  关系：关系型数据库 映射：二者之间的对应关系       Java概念 数据库概念     类 表   属性 字段/列   对象 记录/行     映射文件的命名规则 表所对应的实体类的类名+Mapper.xml  例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml 因此一个映射文件对应一个实体类，对应一张表的操作 MyBatis映射文件用于编写SQL，访问以及操作表中的数据 MyBatis映射文件存放的位置是src/main/resources/mappers目录下   MyBatis中可以面向接口操作数据，要保证两个一致 mapper接口的全类名和映射文件的命名空间（namespace）保持一致  mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致    1 2 3 4 5 6 7 8 9 10  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.atguigu.mybatis.mapper.UserMapper\u0026#34;\u0026gt; \u0026lt;!--int insertUser();--\u0026gt; \u0026lt;insert id=\u0026#34;insertUser\u0026#34;\u0026gt; insert into t_user values(null,\u0026#39;张三\u0026#39;,\u0026#39;123\u0026#39;,23,\u0026#39;女\u0026#39;) \u0026lt;/insert\u0026gt; \u0026lt;/mapper\u0026gt;   通过junit测试功能  SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话） SqlSessionFactory：是“生产”SqlSession的“工厂” 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  public class UserMapperTest { @Test public void testInsertUser() throws IOException { //读取MyBatis的核心配置文件  InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); //获取SqlSessionFactoryBuilder对象  SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象  SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //获取sqlSession，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务  //SqlSession sqlSession = sqlSessionFactory.openSession(); \t//创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交 \tSqlSession sqlSession = sqlSessionFactory.openSession(true); //通过代理模式创建UserMapper接口的代理实现类对象  UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句  int result = userMapper.insertUser(); //提交事务  //sqlSession.commit();  System.out.println(\u0026#34;result:\u0026#34; + result); } }    此时需要手动提交事务，如果要自动提交事务，则在获取sqlSession对象时，使用SqlSession sqlSession = sqlSessionFactory.openSession(true);，传入一个Boolean类型的参数，值为true，这样就可以自动提交  加入log4j日志功能   加入依赖\n1 2 3 4 5 6  \u0026lt;!-- log4j日志 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;     加入log4j的配置文件\n log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下 日志的级别：FATAL(致命)\u0026gt;ERROR(错误)\u0026gt;WARN(警告)\u0026gt;INFO(信息)\u0026gt;DEBUG(调试) 从左到右打印的内容越来越详细  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE log4j:configuration SYSTEM \u0026#34;log4j.dtd\u0026#34;\u0026gt; \u0026lt;log4j:configuration xmlns:log4j=\u0026#34;http://jakarta.apache.org/log4j/\u0026#34;\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;org.apache.log4j.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;Encoding\u0026#34; value=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;layout class=\u0026#34;org.apache.log4j.PatternLayout\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;ConversionPattern\u0026#34; value=\u0026#34;%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \\n\u0026#34; /\u0026gt; \u0026lt;/layout\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;logger name=\u0026#34;java.sql\u0026#34;\u0026gt; \u0026lt;level value=\u0026#34;debug\u0026#34; /\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;logger name=\u0026#34;org.apache.ibatis\u0026#34;\u0026gt; \u0026lt;level value=\u0026#34;info\u0026#34; /\u0026gt; \u0026lt;/logger\u0026gt; \u0026lt;root\u0026gt; \u0026lt;level value=\u0026#34;debug\u0026#34; /\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/log4j:configuration\u0026gt;     核心配置文件详解  核心配置文件中的标签必须按照固定的顺序(有的标签可以不写，但顺序一定不能乱)： properties、settings、typeAliases、typeHandlers、objectFactory、objectWrapperFactory、reflectorFactory、plugins、environments、databaseIdProvider、mappers\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//MyBatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://MyBatis.org/dtd/MyBatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--引入properties文件，此时就可以${属性名}的方式访问属性值--\u0026gt; \u0026lt;properties resource=\u0026#34;jdbc.properties\u0026#34;\u0026gt;\u0026lt;/properties\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!--将表中字段的下划线自动转换为驼峰--\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;!--开启延迟加载--\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，且别名不区分大小写。若不设置此属性，该类型拥有默认的别名，即类名 --\u0026gt; \u0026lt;!--\u0026lt;typeAlias type=\u0026#34;com.atguigu.mybatis.bean.User\u0026#34;\u0026gt;\u0026lt;/typeAlias\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;typeAlias type=\u0026#34;com.atguigu.mybatis.bean.User\u0026#34; alias=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;/typeAlias\u0026gt;--\u0026gt; \u0026lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--\u0026gt; \u0026lt;package name=\u0026#34;com.atguigu.mybatis.bean\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --\u0026gt; \u0026lt;environments default=\u0026#34;mysql_test\u0026#34;\u0026gt; \u0026lt;!-- environment：设置具体的连接数据库的环境信息 属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境 --\u0026gt; \u0026lt;environment id=\u0026#34;mysql_test\u0026#34;\u0026gt; \u0026lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=\u0026#34;JDBC|MANAGED\u0026#34; type=\u0026#34;JDBC\u0026#34;：设置当前环境的事务管理都必须手动处理 type=\u0026#34;MANAGED\u0026#34;：设置事务被管理，例如spring中的AOP --\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=\u0026#34;POOLED|UNPOOLED|JNDI\u0026#34; type=\u0026#34;POOLED\u0026#34;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建 type=\u0026#34;UNPOOLED\u0026#34;：不使用数据库连接池，即每次使用连接都需要重新创建 type=\u0026#34;JNDI\u0026#34;：调用上下文中的数据源 --\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;!--设置驱动类的全类名--\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;!--设置连接数据库的连接地址--\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;!--设置连接数据库的用户名--\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;!--设置连接数据库的密码--\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;!--引入映射文件--\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;!-- \u0026lt;mapper resource=\u0026#34;UserMapper.xml\u0026#34;/\u0026gt; --\u0026gt; \u0026lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意： 1. 此方式必须保证mapper接口和mapper映射文件必须在相同的包下 2. mapper接口要和mapper映射文件的名字一致 --\u0026gt; \u0026lt;package name=\u0026#34;com.atguigu.mybatis.mapper\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;      默认的类型别名 MyBatis的增删改查   添加\n1 2 3 4  \u0026lt;!--int insertUser();--\u0026gt; \u0026lt;insert id=\u0026#34;insertUser\u0026#34;\u0026gt; insert into t_user values(null,\u0026#39;admin\u0026#39;,\u0026#39;123456\u0026#39;,23,\u0026#39;男\u0026#39;,\u0026#39;12345@qq.com\u0026#39;) \u0026lt;/insert\u0026gt;     删除\n1 2 3 4  \u0026lt;!--int deleteUser();--\u0026gt; \u0026lt;delete id=\u0026#34;deleteUser\u0026#34;\u0026gt; delete from t_user where id = 6 \u0026lt;/delete\u0026gt;     修改\n1 2 3 4  \u0026lt;!--int updateUser();--\u0026gt; \u0026lt;update id=\u0026#34;updateUser\u0026#34;\u0026gt; update t_user set username = \u0026#39;张三\u0026#39; where id = 5 \u0026lt;/update\u0026gt;     查询一个实体类对象\n1 2 3 4  \u0026lt;!--User getUserById();--\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; resultType=\u0026#34;com.atguigu.mybatis.bean.User\u0026#34;\u0026gt; select * from t_user where id = 2 \u0026lt;/select\u0026gt;     查询集合\n1 2 3 4  \u0026lt;!--List\u0026lt;User\u0026gt; getUserList();--\u0026gt; \u0026lt;select id=\u0026#34;getUserList\u0026#34; resultType=\u0026#34;com.atguigu.mybatis.bean.User\u0026#34;\u0026gt; select * from t_user \u0026lt;/select\u0026gt;       注意：\n 查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系  resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况   当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值    MyBatis获取参数值的两种方式（重点）  MyBatis获取参数值的两种方式：${}和#{} ${}的本质就是字符串拼接，#{}的本质就是占位符赋值 ${}使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#{}使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号  单个字面量类型的参数  若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称（最好见名识意）获取参数的值，注意${}需要手动加单引号  1 2 3 4  \u0026lt;!--User getUserByUsername(String username);--\u0026gt; \u0026lt;select id=\u0026#34;getUserByUsername\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = #{username} \u0026lt;/select\u0026gt;   1 2 3 4  \u0026lt;!--User getUserByUsername(String username);--\u0026gt; \u0026lt;select id=\u0026#34;getUserByUsername\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = \u0026#39;${username}\u0026#39; \u0026lt;/select\u0026gt;   多个字面量类型的参数   若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中\n 以arg0,arg1\u0026hellip;为键，以参数为值； 以param1,param2\u0026hellip;为键，以参数为值；    因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号。\n  使用arg或者param都行，要注意的是，arg是从arg0开始的，param是从param1开始的\n  1 2 3 4  \u0026lt;!--User checkLogin(String username,String password);--\u0026gt; \u0026lt;select id=\u0026#34;checkLogin\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = #{arg0} and password = #{arg1} \u0026lt;/select\u0026gt;   1 2 3 4  \u0026lt;!--User checkLogin(String username,String password);--\u0026gt; \u0026lt;select id=\u0026#34;checkLogin\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = \u0026#39;${param1}\u0026#39; and password = \u0026#39;${param2}\u0026#39; \u0026lt;/select\u0026gt;   map集合类型的参数  若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号  1 2 3 4  \u0026lt;!--User checkLoginByMap(Map\u0026lt;String,Object\u0026gt; map);--\u0026gt; \u0026lt;select id=\u0026#34;checkLoginByMap\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = #{username} and password = #{password} \u0026lt;/select\u0026gt;   1 2 3 4 5 6 7 8 9 10  @Test public void checkLoginByMap() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); Map\u0026lt;String,Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;usermane\u0026#34;,\u0026#34;admin\u0026#34;); map.put(\u0026#34;password\u0026#34;,\u0026#34;123456\u0026#34;); User user = mapper.checkLoginByMap(map); System.out.println(user); }   实体类类型的参数  若mapper接口中的方法参数为实体类对象时此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号  1 2 3 4  \u0026lt;!--int insertUser(User user);--\u0026gt; \u0026lt;insert id=\u0026#34;insertUser\u0026#34;\u0026gt; insert into t_user values(null,#{username},#{password},#{age},#{sex},#{email}) \u0026lt;/insert\u0026gt;   1 2 3 4 5 6 7  @Test public void insertUser() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); User user = new User(null,\u0026#34;Tom\u0026#34;,\u0026#34;123456\u0026#34;,12,\u0026#34;男\u0026#34;,\u0026#34;123@321.com\u0026#34;); mapper.insertUser(user); }   使用@Param标识参数   可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中\n 以@Param注解的value属性值为键，以参数为值； 以param1,param2\u0026hellip;为键，以参数为值；    只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号\n  1 2 3 4  \u0026lt;!--User CheckLoginByParam(@Param(\u0026#34;username\u0026#34;) String username, @Param(\u0026#34;password\u0026#34;) String password);--\u0026gt; \u0026lt;select id=\u0026#34;CheckLoginByParam\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where username = #{username} and password = #{password} \u0026lt;/select\u0026gt;   1 2 3 4 5 6  @Test public void checkLoginByParam() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); ParameterMapper mapper = sqlSession.getMapper(ParameterMapper.class); mapper.CheckLoginByParam(\u0026#34;admin\u0026#34;,\u0026#34;123456\u0026#34;); }   总结   建议分成两种情况进行处理\n 实体类类型的参数 使用@Param标识参数    MyBatis的各种查询功能  如果查询出的数据只有一条，可以通过  实体类对象接收 List集合接收 Map集合接收，结果{password=123456, sex=男, id=1, age=23, username=admin}   如果查询出的数据有多条，一定不能用实体类对象接收，会抛异常TooManyResultsException，可以通过  实体类类型的LIst集合接收 Map类型的LIst集合接收 在mapper接口的方法上添加@MapKey注解    查询一个实体类对象 1 2 3 4 5 6  /** * 根据用户id查询用户信息 * @param id * @return */ User getUserById(@Param(\u0026#34;id\u0026#34;) int id);   1 2 3 4  \u0026lt;!--User getUserById(@Param(\u0026#34;id\u0026#34;) int id);--\u0026gt; \u0026lt;select id=\u0026#34;getUserById\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user where id = #{id} \u0026lt;/select\u0026gt;   查询一个List集合 1 2 3 4 5  /** * 查询所有用户信息 * @return */ List\u0026lt;User\u0026gt; getUserList();   1 2 3 4  \u0026lt;!--List\u0026lt;User\u0026gt; getUserList();--\u0026gt; \u0026lt;select id=\u0026#34;getUserList\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from t_user \u0026lt;/select\u0026gt;   查询单个数据 1 2 3 4 5 6 7 8 9  /** * 查询用户的总记录数 * @return * 在MyBatis中，对于Java中常用的类型都设置了类型别名 * 例如：java.lang.Integer--\u0026gt;int|integer * 例如：int--\u0026gt;_int|_integer * 例如：Map--\u0026gt;map,List--\u0026gt;list */ int getCount();   1 2 3 4  \u0026lt;!--int getCount();--\u0026gt; \u0026lt;select id=\u0026#34;getCount\u0026#34; resultType=\u0026#34;_integer\u0026#34;\u0026gt; select count(id) from t_user \u0026lt;/select\u0026gt;   查询一条数据为map集合 1 2 3 4 5 6  /** * 根据用户id查询用户信息为map集合 * @param id * @return */ Map\u0026lt;String, Object\u0026gt; getUserToMap(@Param(\u0026#34;id\u0026#34;) int id);   1 2 3 4 5  \u0026lt;!--Map\u0026lt;String, Object\u0026gt; getUserToMap(@Param(\u0026#34;id\u0026#34;) int id);--\u0026gt; \u0026lt;select id=\u0026#34;getUserToMap\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; select * from t_user where id = #{id} \u0026lt;/select\u0026gt; \u0026lt;!--结果：{password=123456, sex=男, id=1, age=23, username=admin}--\u0026gt;   查询多条数据为map集合 方法一 1 2 3 4 5 6  /** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取 */ List\u0026lt;Map\u0026lt;String, Object\u0026gt;\u0026gt; getAllUserToMap();   1 2 3 4 5 6 7 8 9 10  \u0026lt;!--Map\u0026lt;String, Object\u0026gt; getAllUserToMap();--\u0026gt; \u0026lt;select id=\u0026#34;getAllUserToMap\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; select * from t_user \u0026lt;/select\u0026gt; \u0026lt;!-- 结果： [{password=123456, sex=男, id=1, age=23, username=admin}, {password=123456, sex=男, id=2, age=23, username=张三}, {password=123456, sex=男, id=3, age=23, username=张三}] --\u0026gt;   方法二 1 2 3 4 5 6 7  /** * 查询所有用户信息为map集合 * @return * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合 */ @MapKey(\u0026#34;id\u0026#34;) Map\u0026lt;String, Object\u0026gt; getAllUserToMap();   1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!--Map\u0026lt;String, Object\u0026gt; getAllUserToMap();--\u0026gt; \u0026lt;select id=\u0026#34;getAllUserToMap\u0026#34; resultType=\u0026#34;map\u0026#34;\u0026gt; select * from t_user \u0026lt;/select\u0026gt; \u0026lt;!-- 结果： { 1={password=123456, sex=男, id=1, age=23, username=admin}, 2={password=123456, sex=男, id=2, age=23, username=张三}, 3={password=123456, sex=男, id=3, age=23, username=张三} } --\u0026gt;   特殊SQL的执行 模糊查询 1 2 3 4 5 6 7  /** * 根据用户名进行模糊查询 * @param username * @return java.util.List\u0026lt;com.atguigu.mybatis.pojo.User\u0026gt; * @date 2022/2/26 21:56 */ List\u0026lt;User\u0026gt; getUserByLike(@Param(\u0026#34;username\u0026#34;) String username);   1 2 3 4 5 6  \u0026lt;!--List\u0026lt;User\u0026gt; getUserByLike(@Param(\u0026#34;username\u0026#34;) String username);--\u0026gt; \u0026lt;select id=\u0026#34;getUserByLike\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; \u0026lt;!--select * from t_user where username like \u0026#39;%${mohu}%\u0026#39;--\u0026gt; \u0026lt;!--select * from t_user where username like concat(\u0026#39;%\u0026#39;,#{mohu},\u0026#39;%\u0026#39;)--\u0026gt; select * from t_user where username like \u0026#34;%\u0026#34;#{mohu}\u0026#34;%\u0026#34; \u0026lt;/select\u0026gt;    其中select * from t_user where username like \u0026quot;%\u0026quot;#{mohu}\u0026quot;%\u0026quot;是最常用的  批量删除  只能使用${}，如果使用#{}，则解析后的sql语句为delete from t_user where id in ('1,2,3')，这样是将1,2,3看做是一个整体，只有id为1,2,3的数据会被删除。正确的语句应该是delete from t_user where id in (1,2,3)，或者delete from t_user where id in ('1','2','3')  1 2 3 4 5 6 7  /** * 根据id批量删除 * @param ids * @return int * @date 2022/2/26 22:06 */ int deleteMore(@Param(\u0026#34;ids\u0026#34;) String ids);   1 2 3  \u0026lt;delete id=\u0026#34;deleteMore\u0026#34;\u0026gt; delete from t_user where id in (${ids}) \u0026lt;/delete\u0026gt;   1 2 3 4 5 6 7 8  //测试类 @Test public void deleteMore() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); int result = mapper.deleteMore(\u0026#34;1,2,3,8\u0026#34;); System.out.println(result); }   动态设置表名  只能使用${}，因为表名不能加单引号  1 2 3 4 5 6 7  /** * 查询指定表中的数据 * @param tableName * @return java.util.List\u0026lt;com.atguigu.mybatis.pojo.User\u0026gt; * @date 2022/2/27 14:41 */ List\u0026lt;User\u0026gt; getUserByTable(@Param(\u0026#34;tableName\u0026#34;) String tableName);   1 2 3 4  \u0026lt;!--List\u0026lt;User\u0026gt; getUserByTable(@Param(\u0026#34;tableName\u0026#34;) String tableName);--\u0026gt; \u0026lt;select id=\u0026#34;getUserByTable\u0026#34; resultType=\u0026#34;User\u0026#34;\u0026gt; select * from ${tableName} \u0026lt;/select\u0026gt;   添加功能获取自增的主键   使用场景\n  t_clazz(clazz_id,clazz_name)\n t_student(student_id,student_name,clazz_id)   添加班级信息 获取新添加的班级的id 为班级分配学生，即将某学的班级id修改为新添加的班级的id    在mapper.xml中设置两个属性\n  useGeneratedKeys：设置使用自增的主键\n keyProperty：因为增删改有统一的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数user对象的某个属性中    1 2 3 4 5 6  /** * 添加用户信息 * @param user * @date 2022/2/27 15:04 */ void insertUser(User user);   1 2 3 4  \u0026lt;!--void insertUser(User user);--\u0026gt; \u0026lt;insert id=\u0026#34;insertUser\u0026#34; useGeneratedKeys=\u0026#34;true\u0026#34; keyProperty=\u0026#34;id\u0026#34;\u0026gt; insert into t_user values (null,#{username},#{password},#{age},#{sex},#{email}) \u0026lt;/insert\u0026gt;   1 2 3 4 5 6 7 8 9 10  //测试类 @Test public void insertUser() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper mapper = sqlSession.getMapper(SQLMapper.class); User user = new User(null, \u0026#34;ton\u0026#34;, \u0026#34;123\u0026#34;, 23, \u0026#34;男\u0026#34;, \u0026#34;123@321.com\u0026#34;); mapper.insertUser(user); System.out.println(user); //输出：user{id=10, username=\u0026#39;ton\u0026#39;, password=\u0026#39;123\u0026#39;, age=23, sex=\u0026#39;男\u0026#39;, email=\u0026#39;123@321.com\u0026#39;}，自增主键存放到了user的id属性中 }   自定义映射resultMap resultMap处理字段和属性的映射关系  resultMap：设置自定义映射 属性：  id：表示自定义映射的唯一标识，不能重复 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系  result：设置普通字段的映射关系 子标签属性： property：设置映射关系中实体类中的属性名  column：设置映射关系中表中的字段名       若字段名和实体类中的属性名不一致，则可以通过resultMap设置自定义映射，即使字段名和属性名一致的属性也要映射，也就是全部属性都要列出来  1 2 3 4 5 6 7 8 9 10 11  \u0026lt;resultMap id=\u0026#34;empResultMap\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--List\u0026lt;Emp\u0026gt; getAllEmp();--\u0026gt; \u0026lt;select id=\u0026#34;getAllEmp\u0026#34; resultMap=\u0026#34;empResultMap\u0026#34;\u0026gt; select * from t_emp \u0026lt;/select\u0026gt;     若字段名和实体类中的属性名不一致，但是字段名符合数据库的规则（使用_），实体类中的属性名符合Java的规则（使用驼峰）。此时也可通过以下两种方式处理字段名和实体类中的属性的映射关系\n 可以通过为字段起别名的方式，保证和实体类中的属性名保持一致 1 2 3 4  \u0026lt;!--List\u0026lt;Emp\u0026gt; getAllEmp();--\u0026gt; \u0026lt;select id=\u0026#34;getAllEmp\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select eid,emp_name empName,age,sex,email from t_emp \u0026lt;/select\u0026gt;   `` 可以在MyBatis的核心配置文件中的setting标签中，设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将_类型的字段名转换为驼峰，例如：字段名user_name，设置了mapUnderscoreToCamelCase，此时字段名就会转换为userName。核心配置文件详解        多对一映射处理  查询员工信息以及员工所对应的部门信息\n 1 2 3 4 5 6 7 8 9  public class Emp { private Integer eid; private String empName; private Integer age; private String sex; private String email; private Dept dept; //...构造器、get、set方法等 }   级联方式处理映射关系 1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapOne\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;dept.deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Emp getEmpAndDept(@Param(\u0026#34;eid\u0026#34;)Integer eid);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpAndDept\u0026#34; resultMap=\u0026#34;empAndDeptResultMapOne\u0026#34;\u0026gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} \u0026lt;/select\u0026gt;   使用association处理映射关系  association：处理多对一的映射关系 property：需要处理多对的映射关系的属性名 javaType：该属性的类型  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;resultMap id=\u0026#34;empAndDeptResultMapTwo\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; javaType=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Emp getEmpAndDept(@Param(\u0026#34;eid\u0026#34;)Integer eid);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpAndDept\u0026#34; resultMap=\u0026#34;empAndDeptResultMapTwo\u0026#34;\u0026gt; select * from t_emp left join t_dept on t_emp.eid = t_dept.did where t_emp.eid = #{eid} \u0026lt;/select\u0026gt;   分步查询 1. 查询员工信息  select：设置分布查询的sql的唯一标识（namespace.SQLId或mapper接口的全类名.方法名） column：设置分步查询的条件  1 2 3 4 5 6 7 8 9  //EmpMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第一步：查询员工信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:17 */ Emp getEmpAndDeptByStepOne(@Param(\u0026#34;eid\u0026#34;) Integer eid);   1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u0026lt;resultMap id=\u0026#34;empAndDeptByStepResultMap\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; select=\u0026#34;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Emp getEmpAndDeptByStepOne(@Param(\u0026#34;eid\u0026#34;) Integer eid);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpAndDeptByStepOne\u0026#34; resultMap=\u0026#34;empAndDeptByStepResultMap\u0026#34;\u0026gt; select * from t_emp where eid = #{eid} \u0026lt;/select\u0026gt;   2. 查询部门信息 1 2 3 4 5 6 7 8 9  //DeptMapper里的方法 /** * 通过分步查询，员工及所对应的部门信息 * 分步查询第二步：通过did查询员工对应的部门信息 * @param * @return com.atguigu.mybatis.pojo.Emp * @date 2022/2/27 20:23 */ Dept getEmpAndDeptByStepTwo(@Param(\u0026#34;did\u0026#34;) Integer did);   1 2 3 4 5 6 7 8 9  \u0026lt;!--此处的resultMap仅是处理字段和属性的映射关系--\u0026gt; \u0026lt;resultMap id=\u0026#34;EmpAndDeptByStepTwoResultMap\u0026#34; type=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Dept getEmpAndDeptByStepTwo(@Param(\u0026#34;did\u0026#34;) Integer did);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpAndDeptByStepTwo\u0026#34; resultMap=\u0026#34;EmpAndDeptByStepTwoResultMap\u0026#34;\u0026gt; select * from t_dept where did = #{did} \u0026lt;/select\u0026gt;   一对多映射处理 1 2 3 4 5 6  public class Dept { private Integer did; private String deptName; private List\u0026lt;Emp\u0026gt; emps; //...构造器、get、set方法等 }   collection  collection：用来处理一对多的映射关系 ofType：表示该属性对饮的集合中存储的数据的类型  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;resultMap id=\u0026#34;DeptAndEmpResultMap\u0026#34; type=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;collection property=\u0026#34;emps\u0026#34; ofType=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Dept getDeptAndEmp(@Param(\u0026#34;did\u0026#34;) Integer did);--\u0026gt; \u0026lt;select id=\u0026#34;getDeptAndEmp\u0026#34; resultMap=\u0026#34;DeptAndEmpResultMap\u0026#34;\u0026gt; select * from t_dept left join t_emp on t_dept.did = t_emp.did where t_dept.did = #{did} \u0026lt;/select\u0026gt;   分步查询 1. 查询部门信息 1 2 3 4 5 6 7 8  /** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第一步：查询部门信息 * @param did * @return com.atguigu.mybatis.pojo.Dept * @date 2022/2/27 22:04 */ Dept getDeptAndEmpByStepOne(@Param(\u0026#34;did\u0026#34;) Integer did);   1 2 3 4 5 6 7 8 9 10 11  \u0026lt;resultMap id=\u0026#34;DeptAndEmpByStepOneResultMap\u0026#34; type=\u0026#34;Dept\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;did\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;deptName\u0026#34; column=\u0026#34;dept_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;collection property=\u0026#34;emps\u0026#34; select=\u0026#34;com.atguigu.mybatis.mapper.EmpMapper.getDeptAndEmpByStepTwo\u0026#34; column=\u0026#34;did\u0026#34;\u0026gt;\u0026lt;/collection\u0026gt; \u0026lt;/resultMap\u0026gt; \u0026lt;!--Dept getDeptAndEmpByStepOne(@Param(\u0026#34;did\u0026#34;) Integer did);--\u0026gt; \u0026lt;select id=\u0026#34;getDeptAndEmpByStepOne\u0026#34; resultMap=\u0026#34;DeptAndEmpByStepOneResultMap\u0026#34;\u0026gt; select * from t_dept where did = #{did} \u0026lt;/select\u0026gt;   2. 根据部门id查询部门中的所有员工 1 2 3 4 5 6 7 8  /** * 通过分步查询，查询部门及对应的所有员工信息 * 分步查询第二步：根据部门id查询部门中的所有员工 * @param did * @return java.util.List\u0026lt;com.atguigu.mybatis.pojo.Emp\u0026gt; * @date 2022/2/27 22:10 */ List\u0026lt;Emp\u0026gt; getDeptAndEmpByStepTwo(@Param(\u0026#34;did\u0026#34;) Integer did);   1 2 3 4  \u0026lt;!--List\u0026lt;Emp\u0026gt; getDeptAndEmpByStepTwo(@Param(\u0026#34;did\u0026#34;) Integer did);--\u0026gt; \u0026lt;select id=\u0026#34;getDeptAndEmpByStepTwo\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp where did = #{did} \u0026lt;/select\u0026gt;   延迟加载  分步查询的优点：可以实现延迟加载，但是必须在核心配置文件中设置全局配置信息： lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载  aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。 否则，每个属性会按需加载   此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。此时可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=\u0026ldquo;lazy(延迟加载)|eager(立即加载)\u0026rdquo;  1 2 3 4  \u0026lt;settings\u0026gt; \u0026lt;!--开启延迟加载--\u0026gt; \u0026lt;setting name=\u0026#34;lazyLoadingEnabled\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/settings\u0026gt;   1 2 3 4 5 6 7  @Test public void getEmpAndDeptByStepOne() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = mapper.getEmpAndDeptByStepOne(1); System.out.println(emp.getEmpName()); }    关闭延迟加载，两条SQL语句都运行了 开启延迟加载，只运行获取emp的SQL语句   1 2 3 4 5 6 7 8 9  @Test public void getEmpAndDeptByStepOne() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); Emp emp = mapper.getEmpAndDeptByStepOne(1); System.out.println(emp.getEmpName()); System.out.println(\u0026#34;----------------\u0026#34;); System.out.println(emp.getDept()); }     开启后，需要用到查询dept的时候才会调用相应的SQL语句  fetchType：当开启了全局的延迟加载之后，可以通过该属性手动控制延迟加载的效果，fetchType=\u0026ldquo;lazy(延迟加载)|eager(立即加载)\u0026rdquo;\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;resultMap id=\u0026#34;empAndDeptByStepResultMap\u0026#34; type=\u0026#34;Emp\u0026#34;\u0026gt; \u0026lt;id property=\u0026#34;eid\u0026#34; column=\u0026#34;eid\u0026#34;\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;result property=\u0026#34;empName\u0026#34; column=\u0026#34;emp_name\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;age\u0026#34; column=\u0026#34;age\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;sex\u0026#34; column=\u0026#34;sex\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;result property=\u0026#34;email\u0026#34; column=\u0026#34;email\u0026#34;\u0026gt;\u0026lt;/result\u0026gt; \u0026lt;association property=\u0026#34;dept\u0026#34; select=\u0026#34;com.atguigu.mybatis.mapper.DeptMapper.getEmpAndDeptByStepTwo\u0026#34; column=\u0026#34;did\u0026#34; fetchType=\u0026#34;lazy\u0026#34;\u0026gt;\u0026lt;/association\u0026gt; \u0026lt;/resultMap\u0026gt;        动态SQL  Mybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题  if  if标签可通过test属性（即传递过来的数据）的表达式进行判断，若表达式的结果为true，则标签中的内容会执行；反之标签中的内容不会执行 在where后面添加一个恒成立条件1=1 这个恒成立条件并不会影响查询的结果  这个1=1可以用来拼接and语句，例如：当empName为null时 如果不加上恒成立条件，则SQL语句为select * from t_emp where and age = ? and sex = ? and email = ?，此时where会与and连用，SQL语句会报错  如果加上一个恒成立条件，则SQL语句为select * from t_emp where 1= 1 and age = ? and sex = ? and email = ?，此时不报错      1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!--List\u0026lt;Emp\u0026gt; getEmpByCondition(Emp emp);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpByCondition\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp where 1=1 \u0026lt;if test=\u0026#34;empName != null and empName !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and emp_name = #{empName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null and age !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and age = #{age} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;sex != null and sex !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and sex = #{sex} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null and email !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and email = #{email} \u0026lt;/if\u0026gt; \u0026lt;/select\u0026gt;   where  where和if一般结合使用： 若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字  若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and/or去掉    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!--List\u0026lt;Emp\u0026gt; getEmpByCondition(Emp emp);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpByCondition\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp \u0026lt;where\u0026gt; \u0026lt;if test=\u0026#34;empName != null and empName !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; emp_name = #{empName} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null and age !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and age = #{age} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;sex != null and sex !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and sex = #{sex} \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null and email !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; and email = #{email} \u0026lt;/if\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;     注意：where标签不能去掉条件后多余的and/or\n1 2 3 4 5 6 7  \u0026lt;!--这种用法是错误的，只能去掉条件前面的and/or，条件后面的不行--\u0026gt; \u0026lt;if test=\u0026#34;empName != null and empName !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; emp_name = #{empName} and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null and age !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; age = #{age} \u0026lt;/if\u0026gt;        trim  trim用于去掉或添加标签中的内容 常用属性 prefix：在trim标签中的内容的前面添加某些内容  suffix：在trim标签中的内容的后面添加某些内容 prefixOverrides：在trim标签中的内容的前面去掉某些内容 suffixOverrides：在trim标签中的内容的后面去掉某些内容   若trim中的标签都不满足条件，则trim标签没有任何效果，也就是只剩下select * from t_emp  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!--List\u0026lt;Emp\u0026gt; getEmpByCondition(Emp emp);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpByCondition\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp \u0026lt;trim prefix=\u0026#34;where\u0026#34; suffixOverrides=\u0026#34;and|or\u0026#34;\u0026gt; \u0026lt;if test=\u0026#34;empName != null and empName !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; emp_name = #{empName} and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;age != null and age !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; age = #{age} and \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;sex != null and sex !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; sex = #{sex} or \u0026lt;/if\u0026gt; \u0026lt;if test=\u0026#34;email != null and email !=\u0026#39;\u0026#39;\u0026#34;\u0026gt; email = #{email} \u0026lt;/if\u0026gt; \u0026lt;/trim\u0026gt; \u0026lt;/select\u0026gt;   1 2 3 4 5 6 7 8  //测试类 @Test public void getEmpByCondition() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); List\u0026lt;Emp\u0026gt; emps= mapper.getEmpByCondition(new Emp(null, \u0026#34;张三\u0026#34;, null, null, null, null)); System.out.println(emps); }   choose、when、otherwise  choose、when、otherwise相当于if...else if..else when至少要有一个，otherwise至多只有一个  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;select id=\u0026#34;getEmpByChoose\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select * from t_emp \u0026lt;where\u0026gt; \u0026lt;choose\u0026gt; \u0026lt;when test=\u0026#34;empName != null and empName != \u0026#39;\u0026#39;\u0026#34;\u0026gt; emp_name = #{empName} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;age != null and age != \u0026#39;\u0026#39;\u0026#34;\u0026gt; age = #{age} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;sex != null and sex != \u0026#39;\u0026#39;\u0026#34;\u0026gt; sex = #{sex} \u0026lt;/when\u0026gt; \u0026lt;when test=\u0026#34;email != null and email != \u0026#39;\u0026#39;\u0026#34;\u0026gt; email = #{email} \u0026lt;/when\u0026gt; \u0026lt;otherwise\u0026gt; did = 1 \u0026lt;/otherwise\u0026gt; \u0026lt;/choose\u0026gt; \u0026lt;/where\u0026gt; \u0026lt;/select\u0026gt;   1 2 3 4 5 6 7  @Test public void getEmpByChoose() { SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); List\u0026lt;Emp\u0026gt; emps = mapper.getEmpByChoose(new Emp(null, \u0026#34;张三\u0026#34;, 23, \u0026#34;男\u0026#34;, \u0026#34;123@qq.com\u0026#34;, null)); System.out.println(emps); }    相当于if a else if b else if c else d，只会执行其中一个  foreach   属性：\n  collection：设置要循环的数组或集合\n item：表示集合或数组中的每一个数据 separator：设置循环体之间的分隔符，分隔符前后默认有一个空格，如, open：设置foreach标签中的内容的开始符 close：设置foreach标签中的内容的结束符    批量删除\n1 2 3 4 5 6 7  \u0026lt;!--int deleteMoreByArray(Integer[] eids);--\u0026gt; \u0026lt;delete id=\u0026#34;deleteMoreByArray\u0026#34;\u0026gt; delete from t_emp where eid in \u0026lt;foreach collection=\u0026#34;eids\u0026#34; item=\u0026#34;eid\u0026#34; separator=\u0026#34;,\u0026#34; open=\u0026#34;(\u0026#34; close=\u0026#34;)\u0026#34;\u0026gt; #{eid} \u0026lt;/foreach\u0026gt; \u0026lt;/delete\u0026gt;   1 2 3 4 5 6 7  `java est blic void deleteMoreByArray() { lSession sqlSession = SqlSessionUtils.getSqlSession(); namicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); t result = mapper.deleteMoreByArray(new Integer[]{6, 7, 8, 9}); stem.out.println(result);   1  ](Resources/foreach测试结果1.png)     批量添加\n1 2 3 4 5 6 7  \u0026lt;!--int insertMoreByList(@Param(\u0026#34;emps\u0026#34;) List\u0026lt;Emp\u0026gt; emps);--\u0026gt; \u0026lt;insert id=\u0026#34;insertMoreByList\u0026#34;\u0026gt; insert into t_emp values \u0026lt;foreach collection=\u0026#34;emps\u0026#34; item=\u0026#34;emp\u0026#34; separator=\u0026#34;,\u0026#34;\u0026gt; (null,#{emp.empName},#{emp.age},#{emp.sex},#{emp.email},null) \u0026lt;/foreach\u0026gt; \u0026lt;/insert\u0026gt;   1 2 3 4 5 6 7 8 9 10 11  `java est blic void insertMoreByList() { lSession sqlSession = SqlSessionUtils.getSqlSession(); namicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); p emp1 = new Emp(null,\u0026#34;a\u0026#34;,1,\u0026#34;男\u0026#34;,\u0026#34;123@321.com\u0026#34;,null); p emp2 = new Emp(null,\u0026#34;b\u0026#34;,1,\u0026#34;男\u0026#34;,\u0026#34;123@321.com\u0026#34;,null); p emp3 = new Emp(null,\u0026#34;c\u0026#34;,1,\u0026#34;男\u0026#34;,\u0026#34;123@321.com\u0026#34;,null); st\u0026lt;Emp\u0026gt; emps = Arrays.asList(emp1, emp2, emp3); t result = mapper.insertMoreByList(emps); stem.out.println(result);   1  ](Resources/foreach测试结果2.png)     SQL片段  sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入 声明sql片段：\u0026lt;sql\u0026gt;标签  1  \u0026lt;sql id=\u0026#34;empColumns\u0026#34;\u0026gt;eid,emp_name,age,sex,email\u0026lt;/sql\u0026gt;    引用sql片段：\u0026lt;include\u0026gt;标签  1 2 3 4  \u0026lt;!--List\u0026lt;Emp\u0026gt; getEmpByCondition(Emp emp);--\u0026gt; \u0026lt;select id=\u0026#34;getEmpByCondition\u0026#34; resultType=\u0026#34;Emp\u0026#34;\u0026gt; select \u0026lt;include refid=\u0026#34;empColumns\u0026#34;\u0026gt;\u0026lt;/include\u0026gt; from t_emp \u0026lt;/select\u0026gt;   MyBatis的缓存 MyBatis的一级缓存   一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问\n  使一级缓存失效的四种情况：\n 不同的SqlSession对应不同的一级缓存 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存    MyBatis的二级缓存   二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取\n  二级缓存开启的条件\n 在核心配置文件中，设置全局配置属性cacheEnabled=\u0026ldquo;true\u0026rdquo;，默认为true，不需要设置 在映射文件中设置标签 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口    使二级缓存失效的情况：两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效\n  二级缓存的相关配置  在mapper配置文件中添加的cache标签可以设置一些属性 eviction属性：缓存回收策略 LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。  FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认的是 LRU   flushInterval属性：刷新间隔，单位毫秒 默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改）时刷新 size属性：引用数目，正整数 代表缓存最多可以存储多少个对象，太大容易导致内存溢出 readOnly属性：只读，true/false true：只读缓存；会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。  false：读写缓存；会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false    MyBatis缓存查询的顺序  先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 SqlSession关闭之后，一级缓存中的数据会写入二级缓存  整合第三方缓存EHCache（了解） 添加依赖 1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!-- Mybatis EHCache整合包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.caches\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-ehcache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- slf4j日志门面的一个具体实现 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   各个jar包的功能    jar包名称 作用     mybatis-ehcache Mybatis和EHCache的整合包   ehcache EHCache核心包   slf4j-api SLF4J日志门面包   logback-classic 支持SLF4J门面接口的一个具体实现    创建EHCache的配置文件ehcache.xml  名字必须叫ehcache.xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;ehcache xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:noNamespaceSchemaLocation=\u0026#34;../config/ehcache.xsd\u0026#34;\u0026gt; \u0026lt;!-- 磁盘保存路径 --\u0026gt; \u0026lt;diskStore path=\u0026#34;D:\\atguigu\\ehcache\u0026#34;/\u0026gt; \u0026lt;defaultCache maxElementsInMemory=\u0026#34;1000\u0026#34; maxElementsOnDisk=\u0026#34;10000000\u0026#34; eternal=\u0026#34;false\u0026#34; overflowToDisk=\u0026#34;true\u0026#34; timeToIdleSeconds=\u0026#34;120\u0026#34; timeToLiveSeconds=\u0026#34;120\u0026#34; diskExpiryThreadIntervalSeconds=\u0026#34;120\u0026#34; memoryStoreEvictionPolicy=\u0026#34;LRU\u0026#34;\u0026gt; \u0026lt;/defaultCache\u0026gt; \u0026lt;/ehcache\u0026gt;   设置二级缓存的类型  在xxxMapper.xml文件中设置二级缓存类型  1  \u0026lt;cache type=\u0026#34;org.mybatis.caches.ehcache.EhcacheCache\u0026#34;/\u0026gt;   加入logback日志  存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志。创建logback的配置文件logback.xml，名字固定，不可改变  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration debug=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!-- 指定日志输出的位置 --\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;!-- 日志输出的格式 --\u0026gt; \u0026lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --\u0026gt; \u0026lt;pattern\u0026gt;[%d{HH:mm:ss.SSS}] [%-5level] [%thread] [%logger] [%msg]%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --\u0026gt; \u0026lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --\u0026gt; \u0026lt;root level=\u0026#34;DEBUG\u0026#34;\u0026gt; \u0026lt;!-- 指定打印日志的appender，这里通过“STDOUT”引用了前面配置的appender --\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;!-- 根据特殊需求指定局部日志级别 --\u0026gt; \u0026lt;logger name=\u0026#34;com.atguigu.crowd.mapper\u0026#34; level=\u0026#34;DEBUG\u0026#34;/\u0026gt; \u0026lt;/configuration\u0026gt;   EHCache配置文件说明    属性名 是否必须 作用     maxElementsInMemory 是 在内存中缓存的element的最大数目   maxElementsOnDisk 是 在磁盘上缓存的element的最大数目，若是0表示无穷大   eternal 是 设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断   overflowToDisk 是 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上   timeToIdleSeconds 否 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大   timeToLiveSeconds 否 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大   diskSpoolBufferSizeMB 否 DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区   diskPersistent 否 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false   diskExpiryThreadIntervalSeconds 否 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作   memoryStoreEvictionPolicy 否 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出    MyBatis的逆向工程  正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源： Java实体类  Mapper接口 Mapper映射文件    创建逆向工程的步骤 添加依赖和插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  \u0026lt;dependencies\u0026gt; \u0026lt;!-- MyBatis核心依赖包 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.5.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- junit测试 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.13.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySQL驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.27\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- log4j日志 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;!-- 控制Maven在构建过程中相关配置 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!-- 构建过程中用到的插件 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.0\u0026lt;/version\u0026gt; \u0026lt;!-- 插件的依赖 --\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!-- 逆向工程的核心依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.generator\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-generator-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 数据库连接池 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.mchange\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- MySQL驱动 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0.27\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;   创建MyBatis的核心配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;properties resource=\u0026#34;jdbc.properties\u0026#34;/\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34;/\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34;/\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;package name=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt;   创建逆向工程的配置文件  文件名必须是：generatorConfig.xml  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE generatorConfiguration PUBLIC \u0026#34;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\u0026#34;\u0026gt; \u0026lt;generatorConfiguration\u0026gt; \u0026lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD（清新简洁版） MyBatis3: 生成带条件的CRUD（奢华尊享版） --\u0026gt; \u0026lt;context id=\u0026#34;DB2Tables\u0026#34; targetRuntime=\u0026#34;MyBatis3Simple\u0026#34;\u0026gt; \u0026lt;!-- 数据库的连接信息 --\u0026gt; \u0026lt;jdbcConnection driverClass=\u0026#34;com.mysql.cj.jdbc.Driver\u0026#34; connectionURL=\u0026#34;jdbc:mysql://localhost:3306/mybatis\u0026#34; userId=\u0026#34;root\u0026#34; password=\u0026#34;123456\u0026#34;\u0026gt; \u0026lt;/jdbcConnection\u0026gt; \u0026lt;!-- javaBean的生成策略--\u0026gt; \u0026lt;javaModelGenerator targetPackage=\u0026#34;com.atguigu.mybatis.pojo\u0026#34; targetProject=\u0026#34;.\\src\\main\\java\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;trimStrings\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/javaModelGenerator\u0026gt; \u0026lt;!-- SQL映射文件的生成策略 --\u0026gt; \u0026lt;sqlMapGenerator targetPackage=\u0026#34;com.atguigu.mybatis.mapper\u0026#34; targetProject=\u0026#34;.\\src\\main\\resources\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/sqlMapGenerator\u0026gt; \u0026lt;!-- Mapper接口的生成策略 --\u0026gt; \u0026lt;javaClientGenerator type=\u0026#34;XMLMAPPER\u0026#34; targetPackage=\u0026#34;com.atguigu.mybatis.mapper\u0026#34; targetProject=\u0026#34;.\\src\\main\\java\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;enableSubPackages\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/javaClientGenerator\u0026gt; \u0026lt;!-- 逆向分析的表 --\u0026gt; \u0026lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --\u0026gt; \u0026lt;!-- domainObjectName属性指定生成出来的实体类的类名 --\u0026gt; \u0026lt;table tableName=\u0026#34;t_emp\u0026#34; domainObjectName=\u0026#34;Emp\u0026#34;/\u0026gt; \u0026lt;table tableName=\u0026#34;t_dept\u0026#34; domainObjectName=\u0026#34;Dept\u0026#34;/\u0026gt; \u0026lt;/context\u0026gt; \u0026lt;/generatorConfiguration\u0026gt;   执行MBG插件的generate目标   如果出现报错：Exception getting JDBC Driver，可能是pom.xml中，数据库驱动配置错误 dependency中的驱动 mybatis-generator-maven-plugin插件中的驱动 两者的驱动版本应该相同   执行结果  QBC 查询  selectByExample：按条件查询，需要传入一个example对象或者null；如果传入一个null，则表示没有条件，也就是查询所有数据 example.createCriteria().xxx：创建条件对象，通过andXXX方法为SQL添加查询添加，每个条件之间是and关系 example.or().xxx：将之前添加的条件通过or拼接其他条件   1 2 3 4 5 6 7 8 9 10 11 12 13 14  @Test public void testMBG() throws IOException { InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); EmpExample example = new EmpExample(); //名字为张三，且年龄大于等于20 \texample.createCriteria().andEmpNameEqualTo(\u0026#34;张三\u0026#34;).andAgeGreaterThanOrEqualTo(20); //或者did不为空 \texample.or().andDidIsNotNull(); List\u0026lt;Emp\u0026gt; emps = mapper.selectByExample(example); emps.forEach(System.out::println); }   增改  updateByPrimaryKey：通过主键进行数据修改，如果某一个值为null，也会将对应的字段改为null mapper.updateByPrimaryKey(new Emp(1,\u0026quot;admin\u0026quot;,22,null,\u0026quot;456@qq.com\u0026quot;,3));     updateByPrimaryKeySelective()：通过主键进行选择性数据修改，如果某个值为null，则不修改这个字段 mapper.updateByPrimaryKeySelective(new Emp(2,\u0026quot;admin2\u0026quot;,22,null,\u0026quot;456@qq.com\u0026quot;,3));      分页插件 分页插件使用步骤 添加依赖 1 2 3 4 5 6  \u0026lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.pagehelper\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;pagehelper\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   配置分页插件  在MyBatis的核心配置文件（mybatis-config.xml）中配置插件   1 2 3 4  \u0026lt;plugins\u0026gt; \u0026lt;!--设置分页插件--\u0026gt; \u0026lt;plugin interceptor=\u0026#34;com.github.pagehelper.PageInterceptor\u0026#34;\u0026gt;\u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt;   分页插件的使用 开启分页功能  在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能 pageNum：当前页的页码  pageSize：每页显示的条数    1 2 3 4 5 6 7 8 9 10 11 12  @Test public void testPageHelper() throws IOException { InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //访问第一页，每页四条数据 \tPageHelper.startPage(1,4); List\u0026lt;Emp\u0026gt; emps = mapper.selectByExample(null); emps.forEach(System.out::println); }   分页相关数据 方法一：直接输出 1 2 3 4 5 6 7 8 9 10 11 12 13  @Test public void testPageHelper() throws IOException { InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); //访问第一页，每页四条数据 \tPage\u0026lt;Object\u0026gt; page = PageHelper.startPage(1, 4); List\u0026lt;Emp\u0026gt; emps = mapper.selectByExample(null); //在查询到List集合后，打印分页数据 \tSystem.out.println(page); }     分页相关数据：\n1  Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName=\u0026#39;admin\u0026#39;, age=22, sex=\u0026#39;男\u0026#39;, email=\u0026#39;456@qq.com\u0026#39;, did=3}, Emp{eid=2, empName=\u0026#39;admin2\u0026#39;, age=22, sex=\u0026#39;男\u0026#39;, email=\u0026#39;456@qq.com\u0026#39;, did=3}, Emp{eid=3, empName=\u0026#39;王五\u0026#39;, age=12, sex=\u0026#39;女\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;, did=3}, Emp{eid=4, empName=\u0026#39;赵六\u0026#39;, age=32, sex=\u0026#39;男\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;, did=1}]        方法二使用PageInfo  在查询获取list集合之后，使用PageInfo\u0026lt;T\u0026gt; pageInfo = new PageInfo\u0026lt;\u0026gt;(List\u0026lt;T\u0026gt; list, intnavigatePages)获取分页相关数据 list：分页之后的数据  navigatePages：导航分页的页码数    1 2 3 4 5 6 7 8 9 10 11 12  @Test public void testPageHelper() throws IOException { InputStream is = Resources.getResourceAsStream(\u0026#34;mybatis-config.xml\u0026#34;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmpMapper mapper = sqlSession.getMapper(EmpMapper.class); PageHelper.startPage(1, 4); List\u0026lt;Emp\u0026gt; emps = mapper.selectByExample(null); PageInfo\u0026lt;Emp\u0026gt; page = new PageInfo\u0026lt;\u0026gt;(emps,5); System.out.println(page); }     分页相关数据：\n1 2 3 4  PageInfo{ pageNum=1, pageSize=4, size=4, startRow=1, endRow=4, total=8, pages=2, list=Page{count=true, pageNum=1, pageSize=4, startRow=0, endRow=4, total=8, pages=2, reasonable=false, pageSizeZero=false}[Emp{eid=1, empName=\u0026#39;admin\u0026#39;, age=22, sex=\u0026#39;男\u0026#39;, email=\u0026#39;456@qq.com\u0026#39;, did=3}, Emp{eid=2, empName=\u0026#39;admin2\u0026#39;, age=22, sex=\u0026#39;男\u0026#39;, email=\u0026#39;456@qq.com\u0026#39;, did=3}, Emp{eid=3, empName=\u0026#39;王五\u0026#39;, age=12, sex=\u0026#39;女\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;, did=3}, Emp{eid=4, empName=\u0026#39;赵六\u0026#39;, age=32, sex=\u0026#39;男\u0026#39;, email=\u0026#39;123@qq.com\u0026#39;, did=1}], prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=5, navigateFirstPage=1, navigateLastPage=2, navigatepageNums=[1, 2]}        其中list中的数据等同于方法一中直接输出的page数据\n  常用数据：  pageNum：当前页的页码 pageSize：每页显示的条数 size：当前页显示的真实条数 total：总记录数 pages：总页数 prePage：上一页的页码 nextPage：下一页的页码 isFirstPage/isLastPage：是否为第一页/最后一页 hasPreviousPage/hasNextPage：是否存在上一页/下一页 navigatePages：导航分页的页码数 navigatepageNums：导航分页的页码，[1,2,3,4,5]  ","date":"2022-03-14T17:32:29+08:00","image":"https://vigorwei.github.io/p/mybatis/wallhaven-279676_hude352cef37aba5d2c00ac1368a1ddcc4_60382_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/mybatis/","title":"Mybatis"},{"content":"堆排序 堆排序基本介绍\n1)堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。\n2)堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。\n3)每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆\n大顶堆举例说明\n小顶堆举例说明\n一般升序采用大顶堆，降序采用小顶堆\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  public class StackSortDemo { public static void main(String[] args) { int[] arr = {4,6,8,5,9,0,3}; stacksort(arr); System.out.println(Arrays.toString(arr)); } public static void stacksort(int[] arr){ for (int i = arr.length/2 -1; i \u0026gt;=0; i--) { heap(arr,i,arr.length); } for (int i = arr.length-1; i \u0026gt;=0; i--) { int tmp = arr[i]; arr[i] = arr[0]; arr[0] = tmp; heap(arr,0,i); } } public static void heap(int[] arr,int i,int length){ int tmp = arr[i]; for (int j = 2*i+1; j \u0026lt; length; j = 2*j+1) { if(j+1\u0026lt;length\u0026amp;\u0026amp;arr[j]\u0026lt;arr[j+1]){ j++; } if(arr[j]\u0026gt;tmp){ arr[i] = arr[j]; i = j; }else { break; } } arr[i] = tmp; } }   ","date":"2022-03-13T17:14:49+08:00","image":"https://vigorwei.github.io/p/%E5%A0%86%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%A0%86%E6%8E%92%E5%BA%8F/","title":"堆排序"},{"content":"基数排序 基数排序基本思想\n1)将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。\n2)这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤\n图解 将数组 {53, 3, 542, 748, 14, 214} 使用基数排序, 进行升序排序。\n   ","date":"2022-03-13T17:08:22+08:00","image":"https://vigorwei.github.io/p/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/","title":"基数排序"},{"content":"归并排序 归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治**(conquer)的阶段则将分的阶段得到的各答案\u0026quot;修补\u0026quot;在一起，即分而治之)****。**\n图解 我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60  public class MergeSortDemo { public static void main(String[] args) { int[] arr = {8,4,5,7,1,3,6,2,0,234}; int[] nums = new int[arr.length]; mergeRecur(arr,0,arr.length-1,nums); System.out.println(Arrays.toString(arr)); } public static void mergeRecur(int[] arr,int left, int right,int[] nums){ if(left\u0026lt;right){ //System.out.println(\u0026#34;##########\u0026#34;); int mid = (left+right)/2; mergeRecur(arr,left,mid,nums); mergeRecur(arr,mid+1,right,nums); mergeSort(arr,left,mid,right,nums); } } public static void mergeSort(int[] arr,int left,int mid, int right,int[] nums){ int i = left; int j = mid+1; int t = 0; while(i\u0026lt;=mid\u0026amp;\u0026amp;j\u0026lt;=right){ if(arr[i]\u0026lt;=arr[j]){ nums[t] = arr[i]; t+=1; i+=1; }else { nums[t] = arr[j]; t+=1; j+=1; } } while(i\u0026lt;=mid){ nums[t] = arr[i]; t+=1; i+=1; } while(j\u0026lt;=right){ nums[t] = arr[j]; t+=1; j+=1; } int templeft = left; int tempindex = 0; System.out.println(Arrays.toString(nums)); while (templeft\u0026lt;=right){ arr[templeft] = nums[tempindex]; templeft++; tempindex++; }   ","date":"2022-03-13T17:02:27+08:00","image":"https://vigorwei.github.io/p/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","title":"归并排序"},{"content":"快速排序 快速排序（Quicksort）是对冒泡排序的一种改进。基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public class QuickSortDemo { public static void main(String[] args) { int[] arr = {3,4,6,7,2,7,2,8,0,9,1}; quickSort(arr,0,arr.length-1); System.out.println(Arrays.toString(arr)); } public static void quickSort(int[] arr,int start, int end){ if(start\u0026lt;end){ int left = start; int right = end; int pivot = arr[start]; while(left\u0026lt;right){ while(left\u0026lt;right\u0026amp;\u0026amp;arr[right]\u0026gt;=pivot){ right--; } arr[left] = arr[right]; while (left\u0026lt;right\u0026amp;\u0026amp;arr[left]\u0026lt;=pivot){ left++; } arr[right] = arr[left]; } arr[left] = pivot; quickSort(arr,start,left); quickSort(arr,left+1,end); } } }   ","date":"2022-03-13T16:58:49+08:00","image":"https://vigorwei.github.io/p/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","title":"快速排序"},{"content":"希尔排序 简单插入排序存在的问题\n我们看简单的插入排序可能存在的问题.\n数组 arr = {2,3,4,5,6,1} 这时需要插入的数 1(最小), 这样的过程是：\n{2,3,4,5,6,6}\n{2,3,4,5,5,6}\n{2,3,4,4,5,6}\n{2,3,3,4,5,6}\n{2,2,3,4,5,6}\n{1,2,3,4,5,6}\n结论**:** 当需要插入的数是较小的数时，后移的次数明显增多，对效率有影响.\n希尔排序法介绍\n希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序。\n希尔排序法基本思想\n希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止\n图解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  public class ShellSortDemo { public static void main(String[] args) { int[] arr = {8,9,1,7,2,3,5,4,6,0}; shellSort3(arr); //shellSort2(arr); } public static void shellSort3(int[] arr){ for (int gap = arr.length/2; gap \u0026gt;0 ; gap = gap/2) { for (int i = gap; i \u0026lt; arr.length; i+=gap) { //for (int j = i-gap; j \u0026gt;0 ; j--) { int insertValue = arr[i]; int index = i-gap; if(arr[index+gap]\u0026lt;arr[index]) { while (index \u0026gt;= 0 \u0026amp;\u0026amp; arr[index] \u0026gt; insertValue) { arr[index + gap] = arr[index]; index = index - gap; } arr[index + gap] = insertValue; // arr[i] = min; } } } System.out.println(Arrays.toString(arr)); } public static void shellSort(int[] arr){ for(int gap = arr.length/2;gap\u0026gt;0;gap = gap/2) { for (int i = gap; i \u0026lt;arr.length; i += gap) { for (int j = i-gap; j \u0026gt;= 0; j --) { if (arr[j] \u0026gt; arr[j + gap]) { int temp = arr[j]; arr[j] = arr[j + gap]; arr[j + gap] = temp; } } } } System.out.println(Arrays.toString(arr)); }   ","date":"2022-03-13T16:54:12+08:00","image":"https://vigorwei.github.io/p/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/","title":"希尔排序"},{"content":"插入排序 插入排序（Insertion Sorting）的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。\n图解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public class InsertSortDemo { public static void main(String[] args) { int[] arr = new int[]{101,34,29,1,7}; // int[] arr = new int[80000]; // for (int i = 0; i \u0026lt; 80000; i++) { // arr[i] = (int) (Math.random()*80000); // } Date date1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); String s1 = simpleDateFormat.format(date1); System.out.println(\u0026#34;排序前的时间 \u0026#34;+ s1); insertSort(arr); Date date2 = new Date(); String s2 = simpleDateFormat.format(date2); System.out.println(\u0026#34;排序后 \u0026#34;+ s2); } public static void insertSort(int[] arr){ for (int i = 1; i \u0026lt; arr.length; i++) { int insertValue = arr[i]; int insertIndex = i-1; while(insertIndex\u0026gt;=0\u0026amp;\u0026amp;insertValue\u0026lt;arr[insertIndex]){ arr[insertIndex+1] = arr[insertIndex]; insertIndex--; } arr[insertIndex+1] = insertValue; } System.out.println(Arrays.toString(arr)); } }   ","date":"2022-03-13T16:48:47+08:00","image":"https://vigorwei.github.io/p/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","title":"插入排序"},{"content":"选择排序 选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。\n冒泡排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  public class SelectSortDemo { public static void main(String[] args) { // int[] arr = new int[]{101,34,29,1}; int[] arr = new int[80000]; for (int i = 0; i \u0026lt; 80000; i++) { arr[i] = (int) (Math.random()*80000); } Date date1 = new Date(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); String s1 = simpleDateFormat.format(date1); System.out.println(\u0026#34;排序前的时间 \u0026#34;+ s1); selectDemo(arr); Date date2 = new Date(); String s2 = simpleDateFormat.format(date2); System.out.println(\u0026#34;排序后 \u0026#34;+ s2); } public static void selectDemo(int[] arr){ for (int j = 0; j \u0026lt; arr.length-1; j++) { int min = arr[j]; int minIndex = j; for (int i = j+1; i \u0026lt; arr.length; i++) { if(arr[i]\u0026lt;min){ min = arr[i]; minIndex = i; } } arr[minIndex] = arr[j]; arr[j] = min; } // System.out.println(Arrays.toString(arr)); }   ","date":"2022-03-13T16:35:46+08:00","image":"https://vigorwei.github.io/p/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/","title":"选择排序"},{"content":"冒泡排序 冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始）,依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。\n图解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public class BubbleSortDemo { public static void main(String[] args) { int[] arr = {3,4,6,7,2,7,2,8,0,9,1}; bubbleSort(arr); System.out.println(Arrays.toString(arr)); } public static void bubbleSort(int[] arr){ for (int i = 0; i \u0026lt; arr.length-1; i++) { for (int j = i+1; j \u0026lt; arr.length; j++) { if(arr[i]\u0026gt;arr[j]){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; } } } } }   ","date":"2022-03-13T16:28:52+08:00","image":"https://vigorwei.github.io/p/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/wallhaven-672007-2_hu349411a28258a9cc5f53cf994dab486b_213344_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","title":"冒泡排序"},{"content":"hugo更新指令 往基于github的Hugo静态博客推送新博文的步骤分为以下几步：\n 用hugo new命令新建md文件 用hugo -D 生成public html 文件 前往public目录 用git add -A命令将全部更新的文件添加到暂存区 用git commit 命令将暂存区内容添加到分支 用git push 命令将分支内容推到github上去  hugo常用指令集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  git clone https://github.com/digitalcraftsman/hugo-agency-theme hugo server -t hugo-theme-diaspora-master --buildDrafts hugo new post/blog.md hugo --theme=diaspora --baseUrl=\u0026#34;https://vigorwei.github.io/\u0026#34; --buildDrafts cd public git init git add * git commit -m \u0026#34;我的 hugo 博客第一次提交\u0026#34; git remote add origin https://github.com/LastKnightCoder/lastknightcoder.github.io.git git push -u origin master   开始使用hugo！ 下载安装hugo 我们为了简便快速当然选择hugo的二进制安装方式，源码安装有机会再去学习。 去hugo的官方github仓库下载对应的操作系统版本的Hugo二进制文件: 博主以windows64位操作系统为例，下载对应的Windows-64bit.zip。 下载完成后解压缩得到如上文件。\nMac下直接使用Homebrew安装：(其他步骤同理略)\n1  brew install hugo   hugo环境变量配置 上一步操作，可以看到我们把hugo.exe解压到了D:\\hugo下面。所以hugo命令只能在该目录下才能识别。但是我们想要把博客目录建到其他目录下，这就需要配置环境变量。 此电脑-\u0026gt;右键-\u0026gt;点击属性： 再点击高级系统设置： 点击环境变量 在系统变量中找到path，再点击编辑 点击新建，填入hugo解压的文件目录，比如博主解压在D:\\hugo就填的是D:\\hugo 注意：win10以下系统界面不一样，比如win7，直接在path最前或最后加入地址就行，注意用英文;分号分割开，不会的小白可以问度娘。 配置好后点击确定，然后打开cmd命令行程序就可以在任意位置使用hugo命令了。\nhugo新建博客 win+R键打开运行框，输入cmd打开命令行。 使用如下命令\n1  hugo new site /path/to/site   比如hugo new site E:/hugo/hojunBlog就在E盘hugo文件夹下新建了一个叫hojunBlog的hugo站点。 hugo新建页面和文章 新建一个links页面：\n1  hugo new links.md   links.md 自动生成到了 content/links.md，内容如下\n1 2 3 4 5  ---title:\u0026#34;Links\u0026#34;date:2019-04-11T23:35:53+08:00draft:true---  创建第一篇文章，放到 post 目录，方便之后生成聚合页面。\n1  hugo new post/myfirst.md   links.md 自动生成到了 content/post/myfirst.md，内容如下:(注意这里需要把draft删除掉，不然正式生产的时候不会生成文章，因为draft是草稿)\n1 2 3 4 5  ---title:\u0026#34;Myfirst\u0026#34;date:2019-04-13T23:23:34+08:00draft:true---  hugo安装主题 新建文章后不要着急，还需要安装hugo主题才行。去官方主题列表themes.gohugo.io里去挑选自己想要的主题。 。 我们这里以icarus主题为例来安装主题。github仓库地址github.com/digitalcraftsman/hugo-icarus-theme 根据文档clone主题 在Hugo站点运行的文件夹中\n1 2  cd themes git clone https://github.com/digitalcraftsman/hugo-icarus-theme.git   配置主题 找到icarus主题下的hojunBlog\\themes\\hugo-icarus-theme\\exampleSite\\config.toml复制其内容到根目录下的hojunBlog\\config.toml中，接着修改根目录下的配置文件部分内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13  baseurl = \u0026#34;https://yourname.github.io\u0026#34; languageCode = \u0026#34;en-us\u0026#34; title = \u0026#34;Icarus\u0026#34; # Enable comments by entering your Disqus shortname disqusShortname = \u0026#34;spf13\u0026#34; # Enable Google Analytics by entering your tracking code googleAnalytics = \u0026#34;\u0026#34; # Define the number of posts per page paginate = 10 footnotereturnlinkcontents = \u0026#34;↩\u0026#34; theme = \u0026#34;hugo-icarus-theme\u0026#34; # Comment the themesDir option if you use this theme in production themesDir = \u0026#34;./themes/\u0026#34;   其中重要的是baseurl、theme、themesDir的配置，其他的配置可以之后慢慢设置。baseurl需要改成你的github pages的仓库名，theme、themesDir改成主题目录名和主题路径（上图填的是相对路径）。 其他配置可以参考icarus主题的文档，这里就不做介绍了。\n使用命令来预览、发布主题 在根目录（比如这里是hojunBlog下）执行：\n1  hugo server   然后打开浏览器，输入localhost:1313就可以看到自己的博客了！（注意之前说的文章里的draft: true要删掉哦） 接着就是要发布主题到github上了，注册github，新建yourname.github.io的仓库，配置SSH，复制仓库的github pages地址到之前说的配置的baseurl中(就是https://yourname.github.io)，然后使用命令：\n","date":"2022-03-13T15:05:12+08:00","image":"https://vigorwei.github.io/p/hugo-relate-api/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/hugo-relate-api/","title":"Hugo Relate Api"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用  思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n 图片 1 2 3  ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg)   相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://vigorwei.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu45a5e3ad5e058da6a00650ed8fd40bea_15530_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Italics Bold Code     italics bold code       A B C D E F     Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien    Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   Diff code block 1 2 3 4 5  [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;]   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Fruit  Apple Orange Banana   Dairy  Milk Cheese    Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image \n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2019-03-11T00:00:00Z","image":"https://vigorwei.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n YouTube Privacy Enhanced Shortcode  Twitter Simple Shortcode  Vimeo Simple Shortcode bilibilibi Shortcode Gist Shortcode","date":"2019-03-10T00:00:00Z","permalink":"https://vigorwei.github.io/p/rich-content/","title":"Rich Content"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://vigorwei.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu958d513eeefe5556a31d065479ecc5ac_14205_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  1 2 3  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }}    To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files  Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://vigorwei.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; }  ","date":"2019-03-05T00:00:00Z","image":"https://vigorwei.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_huf941de4769045cdfa8c9ee7036519a2a_35369_120x120_fill_q75_box_smart1.jpg","permalink":"https://vigorwei.github.io/p/emoji-support/","title":"Emoji Support"}]